Reinforcement learning - Wikipedia
2022
https://en.wikipedia.org/wiki/Reinforcement_learning

Main menu Main page Contents Current events Random article About Wikipedia Contact us Donate Help Learn to edit Community portal Recent changes Upload file Search Create account Log in Personal tools Create account Log in learn more Contributions Talk Contents (Top) 1 Introduction 2 Exploration 3 Algorithms for control learning Toggle Algorithms for control learning subsection 3.1 Criterion of optimality 3.1.1 Policy 3.1.2 State-value function 3.2 Brute force 3.3 Value function 3.3.1 Monte Carlo methods 3.3.2 Temporal difference methods 3.3.3 Function approximation methods 3.4 Direct policy search 3.5 Model-based algorithms 4 Theory 5 Research 6 Comparison of reinforcement learning algorithms Toggle Comparison of reinforcement learning algorithms subsection 6.1 Associative reinforcement learning 6.2 Deep reinforcement learning 6.3 Adversarial deep reinforcement learning 6.4 Fuzzy reinforcement learning 6.5 Inverse reinforcement learning 6.6 Safe reinforcement learning 7 See also 8 References 9 Sources 10 Further reading 11 External links Toggle the table of contents Reinforcement learning 35 languages العربية বাংলা Български Bosanski Català Čeština Deutsch Eesti Ελληνικά Español فارسی Français 한국어 Հայերեն Italiano עברית Bahasa Melayu Nederlands 日本語 Norsk bokmål ଓଡ଼ିଆ Polski Runa Simi Русский Simple English Slovenščina کوردی Suomi Svenska Türkçe Українська Tiếng Việt 吴语 粵語 中文 Edit links Article Talk English Read Edit View history Tools Read Edit View history What links here Related changes Upload file Special pages Permanent link Page information Cite this page Get shortened URL Wikidata item Download as PDF Printable version Wikimedia Commons Part of a series on Machine learning and data mining Paradigms Supervised learning Unsupervised learning Online learning Batch learning Meta-learning Semi-supervised learning Self-supervised learning Reinforcement learning Rule-based learning Quantum machine learning Problems Classification Generative model Regression Clustering dimension reduction density estimation Anomaly detection Data Cleaning AutoML Association rules Semantic analysis Structured prediction Feature engineering Feature learning Learning to rank Grammar induction Ontology learning Multimodal learning Supervised learning ( classification • regression ) Apprenticeship learning Decision trees Ensembles Bagging Boosting Random forest k -NN Linear regression Naive Bayes Artificial neural networks Logistic regression Perceptron Relevance vector machine (RVM) Support vector machine (SVM) Clustering BIRCH CURE Hierarchical k -means Fuzzy Expectation–maximization (EM) DBSCAN OPTICS Mean shift Dimensionality reduction Factor analysis CCA ICA LDA NMF PCA PGD t-SNE SDL Structured prediction Graphical models Bayes net Conditional random field Hidden Markov Anomaly detection RANSAC k -NN Local outlier factor Isolation forest Artificial neural network Autoencoder Cognitive computing Deep learning DeepDream Feedforward neural network Recurrent neural network LSTM GRU ESN reservoir computing Restricted Boltzmann machine GAN Diffusion model SOM Convolutional neural network U-Net Transformer Vision Spiking neural network Memtransistor Electrochemical RAM (ECRAM) Reinforcement learning Q-learning SARSA Temporal difference (TD) Multi-agent Self-play Learning with humans Active learning Crowdsourcing Human-in-the-loop Model diagnostics Learning curve Mathematical foundations Kernel machines Bias–variance tradeoff Computational learning theory Empirical risk minimization Occam learning PAC learning Statistical learning VC theory Machine-learning venues ECML PKDD NeurIPS ICML ICLR IJCAI ML JMLR Related articles Glossary of artificial intelligence List of datasets for machine-learning research List of datasets in computer vision and image processing Outline of machine learning.
mw-parser-output .navbar{display:inline;font-size:88%;font-weight:normal}.mw-parser-output .navbar-collapse{float:left;text-align:left}.mw-parser-output .navbar-boxtext{word-spacing:0}.mw-parser-output .navbar ul{display:inline-block;white-space:nowrap;line-height:inherit}.mw-parser-output .navbar-brackets::before{margin-right:-0.125em;content:"[ "}.mw-parser-output .navbar-brackets::after{margin-left:-0.125em;content:" ]"}.mw-parser-output .navbar li{word-spacing:-0.125em}.mw-parser-output .navbar a>span,.mw-parser-output .navbar a>abbr{text-decoration:inherit}.mw-parser-output .navbar-mini abbr{font-variant:small-caps;border-bottom:none;text-decoration:none;cursor:inherit}.mw-parser-output .navbar-ct-full{font-size:114%;margin:0 7em}.mw-parser-output .navbar-ct-mini{font-size:114%;margin:0 4em} v t e Reinforcement learning ( RL ) is an area of machine learning concerned with how intelligent agents ought to take actions in an environment in order to maximize the notion of cumulative reward.
 Reinforcement learning is one of three basic machine learning paradigms , alongside supervised learning and unsupervised learning.
Reinforcement learning differs from supervised learning in not needing labelled input/output pairs to be presented, and in not needing sub-optimal actions to be explicitly corrected. Instead the focus is on finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge).
[1] The environment is typically stated in the form of a Markov decision process (MDP), because many reinforcement learning algorithms for this context use dynamic programming techniques.
[2] The main difference between the classical dynamic programming methods and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the Markov decision process and they target large Markov decision processes where exact methods become infeasible..
mw-parser-output .toclimit-2 .toclevel-1 ul,.mw-parser-output .toclimit-3 .toclevel-2 ul,.mw-parser-output .toclimit-4 .toclevel-3 ul,.mw-parser-output .toclimit-5 .toclevel-4 ul,.mw-parser-output .toclimit-6 .toclevel-5 ul,.mw-parser-output .toclimit-7 .toclevel-6 ul{display:none} Introduction [ edit ] Due to its generality, reinforcement learning is studied in many disciplines, such as game theory , control theory , operations research , information theory , simulation-based optimization , multi-agent systems , swarm intelligence , and statistics.
 In the operations research and control literature, reinforcement learning is called approximate dynamic programming, or neuro-dynamic programming.
The problems of interest in reinforcement learning have also been studied in the theory of optimal control , which is concerned mostly with the existence and characterization of optimal solutions, and algorithms for their exact computation, and less with learning or approximation, particularly in the absence of a mathematical model of the environment. In economics and game theory , reinforcement learning may be used to explain how equilibrium may arise under bounded rationality.
Basic reinforcement learning is modeled as a Markov decision process : a set of environment and agent states, S ; a set of actions, A , of the agent; P a ( s , s ′ ) = Pr ( s t + 1 = s ′ ∣ s t = s , a t = a ) {\displaystyle P_{a}(s,s')=\Pr(s_{t+1}=s'\mid s_{t}=s,a_{t}=a)} , the probability of transition (at time t {\displaystyle t} ) from state s {\displaystyle s} to state s ′ {\displaystyle s'} under action a {\displaystyle a}.
R a ( s , s ′ ) {\displaystyle R_{a}(s,s')} , the immediate reward after transition from s {\displaystyle s} to s ′ {\displaystyle s'} with action a {\displaystyle a}.
The purpose of reinforcement learning is for the agent to learn an optimal, or nearly-optimal, policy that maximizes the "reward function" or other user-provided reinforcement signal that accumulates from the immediate rewards. This is similar to processes that appear to occur in animal psychology. For example, biological brains are hardwired to interpret signals such as pain and hunger as negative reinforcements, and interpret pleasure and food intake as positive reinforcements. In some circumstances, animals can learn to engage in behaviors that optimize these rewards. This suggests that animals are capable of reinforcement learning.
[3] [4] A basic reinforcement learning agent AI interacts with its environment in discrete time steps. At each time t , the agent receives the current state s t {\displaystyle s_{t}} and reward r t {\displaystyle r_{t}}.
 It then chooses an action a t {\displaystyle a_{t}} from the set of available actions, which is subsequently sent to the environment. The environment moves to a new state s t + 1 {\displaystyle s_{t+1}} and the reward r t + 1 {\displaystyle r_{t+1}} associated with the transition ( s t , a t , s t + 1 ) {\displaystyle (s_{t},a_{t},s_{t+1})} is determined. The goal of a reinforcement learning agent is to learn a policy : π : A × S → [ 0 , 1 ] {\displaystyle \pi :A\times S\rightarrow [0,1]} , π ( a , s ) = Pr ( a t = a ∣ s t = s ) {\displaystyle \pi (a,s)=\Pr(a_{t}=a\mid s_{t}=s)} that maximizes the expected cumulative reward.
Formulating the problem as an Markov decision process assumes the agent directly observes the current environmental state; in this case the problem is said to have full observability.
 If the agent only has access to a subset of states, or if the observed states are corrupted by noise, the agent is said to have partial observability , and formally the problem must be formulated as a Partially observable Markov decision process.
 In both cases, the set of actions available to the agent can be restricted. For example, the state of an account balance could be restricted to be positive; if the current value of the state is 3 and the state transition attempts to reduce the value by 4, the transition will not be allowed.
When the agent's performance is compared to that of an agent that acts optimally, the difference in performance gives rise to the notion of regret.
 In order to act near optimally, the agent must reason about the long-term consequences of its actions (i.e., maximize future income), although the immediate reward associated with this might be negative.
Thus, reinforcement learning is particularly well-suited to problems that include a long-term versus short-term reward trade-off. It has been applied successfully to various problems, including energy storage operation, [5] robot control , [6] elevator scheduling , telecommunications , photovoltaic generators dispatch, [7] backgammon , checkers [8] and Go ( AlphaGo ).
Two elements make reinforcement learning powerful: the use of samples to optimize performance and the use of function approximation to deal with large environments. Thanks to these two key components, reinforcement learning can be used in large environments in the following situations: A model of the environment is known, but an analytic solution is not available; Only a simulation model of the environment is given (the subject of simulation-based optimization ); [9] The only way to collect information about the environment is to interact with it.
The first two of these problems could be considered planning problems (since some form of model is available), while the last one could be considered to be a genuine learning problem. However, reinforcement learning converts both planning problems to machine learning problems.
Exploration [ edit ] The exploration vs. exploitation trade-off has been most thoroughly studied through the multi-armed bandit problem and for finite state space Markov decision processes in Burnetas and Katehakis (1997).
[10] Reinforcement learning requires clever exploration mechanisms; randomly selecting actions, without reference to an estimated probability distribution, shows poor performance. The case of (small) finite Markov decision processes is relatively well understood. However, due to the lack of algorithms that scale well with the number of states (or scale to problems with infinite state spaces), simple exploration methods are the most practical.
One such method is ε {\displaystyle \varepsilon } -greedy, where 0 < ε < 1 {\displaystyle 0<\varepsilon <1} is a parameter controlling the amount of exploration vs. exploitation. With probability 1 − ε {\displaystyle 1-\varepsilon } , exploitation is chosen, and the agent chooses the action that it believes has the best long-term effect (ties between actions are broken uniformly at random). Alternatively, with probability ε {\displaystyle \varepsilon } , exploration is chosen, and the action is chosen uniformly at random.
ε {\displaystyle \varepsilon } is usually a fixed parameter but can be adjusted either according to a schedule (making the agent explore progressively less), or adaptively based on heuristics.
[11] Algorithms for control learning [ edit ] Even if the issue of exploration is disregarded and even if the state was observable (assumed hereafter), the problem remains to use past experience to find out which actions lead to higher cumulative rewards.
Criterion of optimality [ edit ] Policy [ edit ] The agent's action selection is modeled as a map called policy : π : A × S → [ 0 , 1 ] {\displaystyle \pi :A\times S\rightarrow [0,1]} π ( a , s ) = Pr ( a t = a ∣ s t = s ) {\displaystyle \pi (a,s)=\Pr(a_{t}=a\mid s_{t}=s)} The policy map gives the probability of taking action a {\displaystyle a} when in state s {\displaystyle s}.
[12] : 61 There are also deterministic policies.
State-value function [ edit ] The value function V π ( s ) {\displaystyle V_{\pi }(s)} is defined as, expected return starting with state s {\displaystyle s} , i.e.
s 0 = s {\displaystyle s_{0}=s} , and successively following policy π {\displaystyle \pi }.
 Hence, roughly speaking, the value function estimates "how good" it is to be in a given state.
[12] : 60 V π ( s ) = E ⁡ [ R ∣ s 0 = s ] = E ⁡ [ ∑ t = 0 ∞ γ t r t ∣ s 0 = s ] , {\displaystyle V_{\pi }(s)=\operatorname {E} [R\mid s_{0}=s]=\operatorname {E} \left[\sum _{t=0}^{\infty }\gamma ^{t}r_{t}\mid s_{0}=s\right],} where the random variable R {\displaystyle R} denotes the return , and is defined as the sum of future discounted rewards: R = ∑ t = 0 ∞ γ t r t , {\displaystyle R=\sum _{t=0}^{\infty }\gamma ^{t}r_{t},} where r t {\displaystyle r_{t}} is the reward at step t {\displaystyle t} , γ ∈ [ 0 , 1 ) {\displaystyle \gamma \in [0,1)} is the discount-rate.
 Gamma is less than 1, so events in the distant future are weighted less than events in the immediate future.
The algorithm must find a policy with maximum expected return. From the theory of Markov decision processes it is known that, without loss of generality, the search can be restricted to the set of so-called stationary policies. A policy is stationary if the action-distribution returned by it depends only on the last state visited (from the observation agent's history). The search can be further restricted to deterministic stationary policies. A deterministic stationary policy deterministically selects actions based on the current state. Since any such policy can be identified with a mapping from the set of states to the set of actions, these policies can be identified with such mappings with no loss of generality.
Brute force [ edit ] The brute force approach entails two steps: For each possible policy, sample returns while following it Choose the policy with the largest expected return One problem with this is that the number of policies can be large, or even infinite. Another is that the variance of the returns may be large, which requires many samples to accurately estimate the return of each policy.
These problems can be ameliorated if we assume some structure and allow samples generated from one policy to influence the estimates made for others. The two main approaches for achieving this are value function estimation and direct policy search.
Value function [ edit ] Value function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy (usually either the "current" [on-policy] or the optimal [off-policy] one).
These methods rely on the theory of Markov decision processes, where optimality is defined in a sense that is stronger than the above one: A policy is called optimal if it achieves the best-expected return from any initial state (i.e., initial distributions play no role in this definition). Again, an optimal policy can always be found amongst stationary policies.
To define optimality in a formal manner, define the value of a policy π {\displaystyle \pi } by V π ( s ) = E [ R ∣ s , π ] , {\displaystyle V^{\pi }(s)=E[R\mid s,\pi ],} where R {\displaystyle R} stands for the return associated with following π {\displaystyle \pi } from the initial state s {\displaystyle s}.
 Defining V ∗ ( s ) {\displaystyle V^{*}(s)} as the maximum possible value of V π ( s ) {\displaystyle V^{\pi }(s)} , where π {\displaystyle \pi } is allowed to change, V ∗ ( s ) = max π V π ( s ).
{\displaystyle V^{*}(s)=\max _{\pi }V^{\pi }(s).} A policy that achieves these optimal values in each state is called optimal.
 Clearly, a policy that is optimal in this strong sense is also optimal in the sense that it maximizes the expected return ρ π {\displaystyle \rho ^{\pi }} , since ρ π = E [ V π ( S ) ] {\displaystyle \rho ^{\pi }=E[V^{\pi }(S)]} , where S {\displaystyle S} is a state randomly sampled from the distribution μ {\displaystyle \mu } of initial states (so μ ( s ) = Pr ( s 0 = s ) {\displaystyle \mu (s)=\Pr(s_{0}=s)} ).
Although state-values suffice to define optimality, it is useful to define action-values. Given a state s {\displaystyle s} , an action a {\displaystyle a} and a policy π {\displaystyle \pi } , the action-value of the pair ( s , a ) {\displaystyle (s,a)} under π {\displaystyle \pi } is defined by Q π ( s , a ) = E ⁡ [ R ∣ s , a , π ] , {\displaystyle Q^{\pi }(s,a)=\operatorname {E} [R\mid s,a,\pi ],\,} where R {\displaystyle R} now stands for the random return associated with first taking action a {\displaystyle a} in state s {\displaystyle s} and following π {\displaystyle \pi } , thereafter.
The theory of Markov decision processes states that if π ∗ {\displaystyle \pi ^{*}} is an optimal policy, we act optimally (take the optimal action) by choosing the action from Q π ∗ ( s , ⋅ ) {\displaystyle Q^{\pi ^{*}}(s,\cdot )} with the highest value at each state, s {\displaystyle s}.
 The action-value function of such an optimal policy ( Q π ∗ {\displaystyle Q^{\pi ^{*}}} ) is called the optimal action-value function and is commonly denoted by Q ∗ {\displaystyle Q^{*}}.
 In summary, the knowledge of the optimal action-value function alone suffices to know how to act optimally.
Assuming full knowledge of the Markov decision process, the two basic approaches to compute the optimal action-value function are value iteration and policy iteration.
 Both algorithms compute a sequence of functions Q k {\displaystyle Q_{k}} ( k = 0 , 1 , 2 , … {\displaystyle k=0,1,2,\ldots } ) that converge to Q ∗ {\displaystyle Q^{*}}.
 Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest (finite) Markov decision processes. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces.
Monte Carlo methods [ edit ] Monte Carlo methods can be used in an algorithm that mimics policy iteration. Policy iteration consists of two steps: policy evaluation and policy improvement.
Monte Carlo is used in the policy evaluation step. In this step, given a stationary, deterministic policy π {\displaystyle \pi } , the goal is to compute the function values Q π ( s , a ) {\displaystyle Q^{\pi }(s,a)} (or a good approximation to them) for all state-action pairs ( s , a ) {\displaystyle (s,a)}.
 Assume (for simplicity) that the Markov decision process is finite, that sufficient memory is available to accommodate the action-values and that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair ( s , a ) {\displaystyle (s,a)} can be computed by averaging the sampled returns that originated from ( s , a ) {\displaystyle (s,a)} over time. Given sufficient time, this procedure can thus construct a precise estimate Q {\displaystyle Q} of the action-value function Q π {\displaystyle Q^{\pi }}.
 This finishes the description of the policy evaluation step.
In the policy improvement step, the next policy is obtained by computing a greedy policy with respect to Q {\displaystyle Q} : Given a state s {\displaystyle s} , this new policy returns an action that maximizes Q ( s , ⋅ ) {\displaystyle Q(s,\cdot )}.
 In practice lazy evaluation can defer the computation of the maximizing actions to when they are needed.
Problems with this procedure include: 1. The procedure may spend too much time evaluating a suboptimal policy.
2. It uses samples inefficiently in that a long trajectory improves the estimate only of the single state-action pair that started the trajectory.
3. When the returns along the trajectories have high variance , convergence is slow.
4. It works in episodic problems only.
5. It works in small, finite Markov decision processes only.
Temporal difference methods [ edit ] The first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class of generalized policy iteration algorithms. Many actor-critic methods belong to this category.
The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton's temporal difference (TD) methods that are based on the recursive Bellman equation.
[13] [14] The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method, [15] may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue.
Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-called λ {\displaystyle \lambda } parameter ( 0 ≤ λ ≤ 1 ) {\displaystyle (0\leq \lambda \leq 1)} that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue.
Function approximation methods [ edit ] In order to address the fifth issue, function approximation methods are used.
Linear function approximation starts with a mapping ϕ {\displaystyle \phi } that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair ( s , a ) {\displaystyle (s,a)} are obtained by linearly combining the components of ϕ ( s , a ) {\displaystyle \phi (s,a)} with some weights θ {\displaystyle \theta } : Q ( s , a ) = ∑ i = 1 d θ i ϕ i ( s , a ).
{\displaystyle Q(s,a)=\sum _{i=1}^{d}\theta _{i}\phi _{i}(s,a).} The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. Methods based on ideas from nonparametric statistics (which can be seen to construct their own features) have been explored.
Value iteration can also be used as a starting point, giving rise to the Q-learning algorithm and its many variants.
[16] Including Deep Q-learning methods when a neural network is used to represent Q, with various applications in stochastic search problems.
[17] The problem with using action-values is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy, though this problem is mitigated to some extent by temporal difference methods. Using the so-called compatible function approximation method compromises generality and efficiency.
Direct policy search [ edit ] An alternative method is to search directly in (some subset of) the policy space, in which case the problem becomes a case of stochastic optimization.
 The two approaches available are gradient-based and gradient-free methods.
Gradient -based methods ( policy gradient methods ) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vector θ {\displaystyle \theta } , let π θ {\displaystyle \pi _{\theta }} denote the policy associated to θ {\displaystyle \theta }.
 Defining the performance function by ρ ( θ ) = ρ π θ , {\displaystyle \rho (\theta )=\rho ^{\pi _{\theta }},} under mild conditions this function will be differentiable as a function of the parameter vector θ {\displaystyle \theta }.
 If the gradient of ρ {\displaystyle \rho } was known, one could use gradient ascent.
 Since an analytic expression for the gradient is not available, only a noisy estimate is available. Such an estimate can be constructed in many ways, giving rise to algorithms such as Williams' REINFORCE method [18] (which is known as the likelihood ratio method in the simulation-based optimization literature).
[19] Policy search methods have been used in the robotics context.
[20] Many policy search methods may get stuck in local optima (as they are based on local search ).
A large class of methods avoids relying on gradient information. These include simulated annealing , cross-entropy search or methods of evolutionary computation.
 Many gradient-free methods can achieve (in theory and in the limit) a global optimum.
Policy search methods may converge slowly given noisy data. For example, this happens in episodic problems when the trajectories are long and the variance of the returns is large. Value-function based methods that rely on temporal differences might help in this case. In recent years, actor–critic methods have been proposed and performed well on various problems.
[21] Model-based algorithms [ edit ] Finally, all of the above methods can be combined with algorithms that first learn a model. For instance, the Dyna algorithm [22] learns a model from experience, and uses that to provide more modelled transitions for a value function, in addition to the real transitions. Such methods can sometimes be extended to use of non-parametric models, such as when the transitions are simply stored and 'replayed' [23] to the learning algorithm.
There are other ways to use models than to update a value function.
[24] For instance, in model predictive control the model is used to update the behavior directly.
Theory [ edit ] Both the asymptotic and finite-sample behaviors of most algorithms are well understood. Algorithms with provably good online performance (addressing the exploration issue) are known.
Efficient exploration of Markov decision processes is given in Burnetas and Katehakis (1997).
[10] Finite-time performance bounds have also appeared for many algorithms, but these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations.
For incremental algorithms, asymptotic convergence issues have been settled [ clarification needed ].
 Temporal-difference-based algorithms converge under a wider set of conditions than was previously possible (for example, when used with arbitrary, smooth function approximation).
Research [ edit ] This section needs additional citations for verification.
Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed.
( October 2022 ) ( Learn how and when to remove this template message ) Research topics include: actor-critic adaptive methods that work with fewer (or no) parameters under a large number of conditions bug detection in software projects [25] continuous learning combinations with logic-based frameworks [26] exploration in large Markov decision processes human feedback [27] interaction between implicit and explicit learning in skill acquisition intrinsic motivation which differentiates information-seeking, curiosity-type behaviours from task-dependent goal-directed behaviours large-scale empirical evaluations large (or continuous) action spaces modular and hierarchical reinforcement learning [28] multiagent/distributed reinforcement learning is a topic of interest. Applications are expanding.
[29] occupant-centric control optimization of computing resources [30] [31] [32] partial information (e.g., using predictive state representation ) reward function based on maximising novel information [33] [34] [35] sample-based planning (e.g., based on Monte Carlo tree search ).
securities trading [36] transfer learning [37] TD learning modeling dopamine -based learning in the brain.
Dopaminergic projections from the substantia nigra to the basal ganglia function are the prediction error.
value-function and policy search methods Comparison of reinforcement learning algorithms [ edit ] Algorithm Description Policy Action space State space Operator Monte Carlo Every visit to Monte Carlo Either Discrete Discrete Sample-means Q-learning State–action–reward–state Off-policy Discrete Discrete Q-value SARSA State–action–reward–state–action On-policy Discrete Discrete Q-value Q-learning - Lambda State–action–reward–state with eligibility traces Off-policy Discrete Discrete Q-value SARSA - Lambda State–action–reward–state–action with eligibility traces On-policy Discrete Discrete Q-value DQN Deep Q Network Off-policy Discrete Continuous Q-value DDPG Deep Deterministic Policy Gradient Off-policy Continuous Continuous Q-value A3C Asynchronous Advantage Actor-Critic Algorithm On-policy Continuous Continuous Advantage NAF Q-Learning with Normalized Advantage Functions Off-policy Continuous Continuous Advantage TRPO Trust Region Policy Optimization On-policy Continuous or Discrete Continuous Advantage PPO Proximal Policy Optimization On-policy Continuous or Discrete Continuous Advantage TD3 Twin Delayed Deep Deterministic Policy Gradient Off-policy Continuous Continuous Q-value SAC Soft Actor-Critic Off-policy Continuous Continuous Advantage Associative reinforcement learning [ edit ] Associative reinforcement learning tasks combine facets of stochastic learning automata tasks and supervised learning pattern classification tasks. In associative reinforcement learning tasks, the learning system interacts in a closed loop with its environment.
[38] Deep reinforcement learning [ edit ] This approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space.
[39] The work on learning ATARI games by Google DeepMind increased attention to deep reinforcement learning or end-to-end reinforcement learning.
[40] Adversarial deep reinforcement learning [ edit ] Adversarial deep reinforcement learning is an active area of research in reinforcement learning focusing on vulnerabilities of learned policies. In this research area some studies initially showed that reinforcement learning policies are susceptible to imperceptible adversarial manipulations.
[41] [42] [43] While some methods have been proposed to overcome these susceptibilities, in the most recent studies it has been shown that these proposed solutions are far from providing an accurate representation of current vulnerabilities of deep reinforcement learning policies.
[44] Fuzzy reinforcement learning [ edit ] By introducing fuzzy inference in reinforcement learning, [45] approximating the state-action value function with fuzzy rules in continuous space becomes possible. The IF - THEN form of fuzzy rules make this approach suitable for expressing the results in a form close to natural language. Extending FRL with Fuzzy Rule Interpolation [46] allows the use of reduced size sparse fuzzy rule-bases to emphasize cardinal rules (most important state-action values).
Inverse reinforcement learning [ edit ] In inverse reinforcement learning (IRL), no reward function is given. Instead, the reward function is inferred given an observed behavior from an expert. The idea is to mimic observed behavior, which is often optimal or close to optimal.
[47] Safe reinforcement learning [ edit ] Safe reinforcement learning (SRL) can be defined as the process of learning policies that maximize the expectation of the return in problems in which it is important to ensure reasonable system performance and/or respect safety constraints during the learning and/or deployment processes.
[48] See also [ edit ] Temporal difference learning Q-learning State–action–reward–state–action (SARSA) Reinforcement learning from human feedback Fictitious play Learning classifier system Optimal control Dynamic treatment regimes Error-driven learning Multi-agent reinforcement learning Multi-agent system Distributed artificial intelligence Intrinsic motivation Genetic algorithms Apprenticeship learning Model-free (reinforcement learning) References [ edit ] ^.
mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit} Kaelbling, Leslie P.
; Littman, Michael L.
; Moore, Andrew W.
(1996).
"Reinforcement Learning: A Survey".
Journal of Artificial Intelligence Research.
4 : 237–285.
arXiv : cs/9605103.
doi : 10.1613/jair.301.
S2CID 1708582.
 Archived from the original on 2001-11-20.
^ van Otterlo, M.; Wiering, M. (2012). "Reinforcement Learning and Markov Decision Processes".
Reinforcement Learning.
 Adaptation, Learning, and Optimization. Vol. 12. pp. 3–42.
doi : 10.1007/978-3-642-27645-3_1.
ISBN 978-3-642-27644-6.
^ Russell, Stuart J.; Norvig, Peter (2010).
Artificial intelligence : a modern approach (Third ed.). Upper Saddle River, New Jersey. pp. 830, 831.
ISBN 978-0-13-604259-4.
{{ cite book }} : CS1 maint: location missing publisher ( link ) ^ Lee, Daeyeol; Seo, Hyojung; Jung, Min Whan (21 July 2012).
"Neural Basis of Reinforcement Learning and Decision Making".
Annual Review of Neuroscience.
35 (1): 287–308.
doi : 10.1146/annurev-neuro-062111-150512.
PMC 3490621.
PMID 22462543.
^ Duque, Edgar Mauricio Salazar, Juan S. Giraldo, Pedro P. Vergara, Phuong Nguyen, Anne van der Molen, and Han Slootweg. "Community energy storage operation via reinforcement learning with eligibility traces." Electric Power Systems Research 212 (2022): 108515.
https://doi.org/10.1016/j.epsr.2022.108515 ^ Xie, Zhaoming, et al. " ALLSTEPS: Curriculum‐driven Learning of Stepping Stone Skills.
" Computer Graphics Forum. Vol. 39. No. 8. 2020.
^ Vergara, Pedro P., Mauricio Salazar, Juan S. Giraldo, and Peter Palensky. "Optimal dispatch of PV inverters in unbalanced distribution systems using Reinforcement Learning." International Journal of Electrical Power & Energy Systems 136 (2022): 107628.
https://doi.org/10.1016/j.ijepes.2021.107628 ^ Sutton & Barto 2018 , Chapter 11.
^ Gosavi, Abhijit (2003).
Simulation-based Optimization: Parametric Optimization Techniques and Reinforcement.
 Operations Research/Computer Science Interfaces Series. Springer.
ISBN 978-1-4020-7454-7.
^ a b Burnetas, Apostolos N.; Katehakis, Michael N.
(1997), "Optimal adaptive policies for Markov Decision Processes", Mathematics of Operations Research , 22 : 222–255, doi : 10.1287/moor.22.1.222 ^ Tokic, Michel; Palm, Günther (2011), "Value-Difference Based Exploration: Adaptive Control Between Epsilon-Greedy and Softmax" (PDF) , KI 2011: Advances in Artificial Intelligence , Lecture Notes in Computer Science, vol. 7006, Springer, pp. 335–346, ISBN 978-3-642-24455-1 ^ a b "Reinforcement learning: An introduction" (PDF).
 Archived from the original (PDF) on 2017-07-12.
 Retrieved 2017-07-23.
^ Sutton, Richard S.
(1984).
Temporal Credit Assignment in Reinforcement Learning (PhD thesis). University of Massachusetts, Amherst, MA. Archived from the original on 2017-03-30.
 Retrieved 2017-03-29.
^ Sutton & Barto 2018 , §6. Temporal-Difference Learning.
^ Bradtke, Steven J.
; Barto, Andrew G.
(1996). "Learning to predict by the method of temporal differences".
Machine Learning.
22 : 33–57.
CiteSeerX 10.1.1.143.857.
doi : 10.1023/A:1018056104778.
S2CID 20327856.
^ Watkins, Christopher J.C.H.
(1989).
Learning from Delayed Rewards (PDF) (PhD thesis). King’s College, Cambridge, UK.
^ Matzliach, Barouch; Ben-Gal, Irad; Kagan, Evgeny (2022).
"Detection of Static and Mobile Targets by an Autonomous Agent with Deep Q-Learning Abilities".
Entropy.
24 (8): 1168.
Bibcode : 2022Entrp..24.1168M.
doi : 10.3390/e24081168.
PMC 9407070.
PMID 36010832.
^ Williams, Ronald J.
(1987). "A class of gradient-estimating algorithms for reinforcement learning in neural networks".
Proceedings of the IEEE First International Conference on Neural Networks.
CiteSeerX 10.1.1.129.8871.
^ Peters, Jan ; Vijayakumar, Sethu ; Schaal, Stefan (2003).
"Reinforcement Learning for Humanoid Robotics" (PDF).
IEEE-RAS International Conference on Humanoid Robots.
^ Deisenroth, Marc Peter ; Neumann, Gerhard ; Peters, Jan (2013).
A Survey on Policy Search for Robotics (PDF).
 Foundations and Trends in Robotics. Vol. 2. NOW Publishers. pp. 1–142.
doi : 10.1561/2300000021.
hdl : 10044/1/12051.
^ Juliani, Arthur (2016-12-17).
"Simple Reinforcement Learning with Tensorflow Part 8: Asynchronous Actor-Critic Agents (A3C)".
Medium.
 Retrieved 2018-02-22.
^ Sutton, Richard (1990). "Integrated Architectures for Learning, Planning and Reacting based on Dynamic Programming".
Machine Learning: Proceedings of the Seventh International Workshop.
^ Lin, Long-Ji (1992).
"Self-improving reactive agents based on reinforcement learning, planning and teaching" (PDF).
Machine Learning volume 8.
doi : 10.1007/BF00992699.
^ van Hasselt, Hado; Hessel, Matteo; Aslanides, John (2019).
"When to use parametric models in reinforcement learning?" (PDF).
Advances in Neural Information Processing Systems 32.
^ "On the Use of Reinforcement Learning for Testing Game Mechanics : ACM - Computers in Entertainment".
cie.acm.org.
 Retrieved 2018-11-27.
^ Riveret, Regis; Gao, Yang (2019). "A probabilistic argumentation framework for reinforcement learning agents".
Autonomous Agents and Multi-Agent Systems.
33 (1–2): 216–274.
doi : 10.1007/s10458-019-09404-2.
S2CID 71147890.
^ Yamagata, Taku; McConville, Ryan; Santos-Rodriguez, Raul (2021-11-16). "Reinforcement Learning with Feedback from Multiple Humans with Diverse Skills".
arXiv : 2111.08596 [ cs.LG ].
^ Kulkarni, Tejas D.; Narasimhan, Karthik R.; Saeedi, Ardavan; Tenenbaum, Joshua B. (2016).
"Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation".
Proceedings of the 30th International Conference on Neural Information Processing Systems.
 NIPS'16. USA: Curran Associates Inc.: 3682–3690.
arXiv : 1604.06057.
Bibcode : 2016arXiv160406057K.
ISBN 978-1-5108-3881-9.
^ "Reinforcement Learning / Successes of Reinforcement Learning".
umichrl.pbworks.com.
 Retrieved 2017-08-06.
^ Dey, Somdip; Singh, Amit Kumar; Wang, Xiaohang; McDonald-Maier, Klaus (March 2020).
"User Interaction Aware Reinforcement Learning for Power and Thermal Efficiency of CPU-GPU Mobile MPSoCs".
2020 Design, Automation Test in Europe Conference Exhibition (DATE) : 1728–1733.
doi : 10.23919/DATE48585.2020.9116294.
ISBN 978-3-9819263-4-7.
S2CID 219858480.
^ Quested, Tony.
"Smartphones get smarter with Essex innovation".
Business Weekly.
 Retrieved 2021-06-17.
^ Williams, Rhiannon (2020-07-21).
"Future smartphones 'will prolong their own battery life by monitoring owners' behaviour' ".
i.
 Retrieved 2021-06-17.
^ Kaplan, F.; Oudeyer, P. (2004). "Maximizing Learning Progress: An Internal Reward System for Development". In Iida, F.; Pfeifer, R.; Steels, L.; Kuniyoshi, Y. (eds.).
Embodied Artificial Intelligence.
 Lecture Notes in Computer Science. Vol. 3139. Berlin; Heidelberg: Springer. pp. 259–270.
doi : 10.1007/978-3-540-27833-7_19.
ISBN 978-3-540-22484-6.
S2CID 9781221.
^ Klyubin, A.; Polani, D.; Nehaniv, C. (2008).
"Keep your options open: an information-based driving principle for sensorimotor systems".
PLOS ONE.
3 (12): e4018.
Bibcode : 2008PLoSO...3.4018K.
doi : 10.1371/journal.pone.0004018.
PMC 2607028.
PMID 19107219.
^ Barto, A. G. (2013). "Intrinsic motivation and reinforcement learning".
Intrinsically Motivated Learning in Natural and Artificial Systems (PDF).
 Berlin; Heidelberg: Springer. pp. 17–47.
^ Dabérius, Kevin; Granat, Elvin; Karlsson, Patrik (2020). "Deep Execution - Value and Policy Based Reinforcement Learning for Trading and Beating Market Benchmarks".
The Journal of Machine Learning in Finance.
1.
SSRN 3374766.
^ George Karimpanal, Thommen; Bouffanais, Roland (2019). "Self-organizing maps for storage and transfer of knowledge in reinforcement learning".
Adaptive Behavior.
27 (2): 111–126.
arXiv : 1811.08318.
doi : 10.1177/1059712318818568.
ISSN 1059-7123.
S2CID 53774629.
^ Soucek, Branko (6 May 1992).
Dynamic, Genetic and Chaotic Programming: The Sixth-Generation Computer Technology Series.
 John Wiley & Sons, Inc. p. 38.
ISBN 0-471-55717-X.
^ Francois-Lavet, Vincent; et al. (2018). "An Introduction to Deep Reinforcement Learning".
Foundations and Trends in Machine Learning.
11 (3–4): 219–354.
arXiv : 1811.12560.
Bibcode : 2018arXiv181112560F.
doi : 10.1561/2200000071.
S2CID 54434537.
^ Mnih, Volodymyr; et al. (2015).
"Human-level control through deep reinforcement learning".
Nature.
518 (7540): 529–533.
Bibcode : 2015Natur.518..529M.
doi : 10.1038/nature14236.
PMID 25719670.
S2CID 205242740.
^ Goodfellow, Ian; Shlens, Jonathan; Szegedy, Christian (2015). "Explaining and Harnessing Adversarial Examples".
International Conference on Learning Representations.
arXiv : 1412.6572.
^ Behzadan, Vahid; Munir, Arslan (2017). "Vulnerability of Deep Reinforcement Learning to Policy Induction Attacks".
Machine Learning and Data Mining in Pattern Recognition.
 Lecture Notes in Computer Science. Vol. 10358. pp. 262–275.
arXiv : 1701.04143.
doi : 10.1007/978-3-319-62416-7_19.
ISBN 978-3-319-62415-0.
S2CID 1562290.
^ Pieter, Huang, Sandy Papernot, Nicolas Goodfellow, Ian Duan, Yan Abbeel (2017-02-07).
Adversarial Attacks on Neural Network Policies.
OCLC 1106256905.
{{ cite book }} : CS1 maint: multiple names: authors list ( link ) ^ Korkmaz, Ezgi (2022).
"Deep Reinforcement Learning Policies Learn Shared Adversarial Features Across MDPs".
Thirty-Sixth AAAI Conference on Artificial Intelligence (AAAI-22).
36 (7): 7229–7238.
doi : 10.1609/aaai.v36i7.20684.
S2CID 245219157.
^ Berenji, H.R. (1994).
"Fuzzy Q-learning: A new approach for fuzzy dynamic programming".
Proceedings of 1994 IEEE 3rd International Fuzzy Systems Conference.
 Orlando, FL, USA: IEEE. pp. 486–491.
doi : 10.1109/FUZZY.1994.343737.
ISBN 0-7803-1896-X.
S2CID 56694947.
^ Vincze, David (2017).
"Fuzzy rule interpolation and reinforcement learning" (PDF).
2017 IEEE 15th International Symposium on Applied Machine Intelligence and Informatics (SAMI).
 IEEE. pp. 173–178.
doi : 10.1109/SAMI.2017.7880298.
ISBN 978-1-5090-5655-2.
S2CID 17590120.
^ Ng, A. Y.; Russell, S. J. (2000).
"Algorithms for Inverse Reinforcement Learning" (PDF).
Proceeding ICML '00 Proceedings of the Seventeenth International Conference on Machine Learning.
 pp. 663–670.
ISBN 1-55860-707-2.
^ García, Javier; Fernández, Fernando (1 January 2015).
"A comprehensive survey on safe reinforcement learning" (PDF).
The Journal of Machine Learning Research.
16 (1): 1437–1480.
Sources [ edit ] Sutton, Richard S.
; Barto, Andrew G.
(2018) [1998].
Reinforcement Learning: An Introduction (2nd ed.). MIT Press.
ISBN 978-0-262-03924-6.
Further reading [ edit ] Annaswamy, Anuradha M. (3 May 2023).
"Adaptive Control and Intersections with Reinforcement Learning".
Annual Review of Control, Robotics, and Autonomous Systems.
6 (1): 65–93.
doi : 10.1146/annurev-control-062922-090153.
ISSN 2573-5144.
S2CID 255702873.
Auer, Peter ; Jaksch, Thomas; Ortner, Ronald (2010).
"Near-optimal regret bounds for reinforcement learning".
Journal of Machine Learning Research.
11 : 1563–1600.
Busoniu, Lucian; Babuska, Robert; De Schutter, Bart ; Ernst, Damien (2010).
Reinforcement Learning and Dynamic Programming using Function Approximators.
 Taylor & Francis CRC Press.
ISBN 978-1-4398-2108-4.
François-Lavet, Vincent; Henderson, Peter; Islam, Riashat; Bellemare, Marc G.; Pineau, Joelle (2018). "An Introduction to Deep Reinforcement Learning".
Foundations and Trends in Machine Learning.
11 (3–4): 219–354.
arXiv : 1811.12560.
Bibcode : 2018arXiv181112560F.
doi : 10.1561/2200000071.
S2CID 54434537.
Powell, Warren (2011).
Approximate dynamic programming: solving the curses of dimensionality.
 Wiley-Interscience. Archived from the original on 2016-07-31.
 Retrieved 2010-09-08.
Sutton, Richard S.
(1988).
"Learning to predict by the method of temporal differences".
Machine Learning.
3 : 9–44.
doi : 10.1007/BF00115009.
 Archived from the original on 2017-03-30.
 Retrieved 2017-03-29.
Szita, Istvan; Szepesvari, Csaba (2010).
"Model-based Reinforcement Learning with Nearly Tight Exploration Complexity Bounds" (PDF).
ICML 2010.
 Omnipress. pp. 1031–1038. Archived from the original (PDF) on 2010-07-14.
External links [ edit ] Reinforcement Learning Repository Reinforcement Learning and Artificial Intelligence (RLAI, Rich Sutton's lab at the University of Alberta ) Autonomous Learning Laboratory (ALL, Andrew Barto's lab at the University of Massachusetts Amherst ) Real-world reinforcement learning experiments Archived 2018-10-08 at the Wayback Machine at Delft University of Technology Stanford University Andrew Ng Lecture on Reinforcement Learning Dissecting Reinforcement Learning Series of blog post on reinforcement learning with Python code A (Long) Peek into Reinforcement Learning v t e Differentiable computing General Differentiable programming Information geometry Statistical manifold Automatic differentiation Neuromorphic engineering Pattern recognition Tensor calculus Computational learning theory Inductive bias Concepts Gradient descent SGD Clustering Regression Overfitting Hallucination Adversary Attention Convolution Loss functions Backpropagation Batchnorm Activation Softmax Sigmoid Rectifier Regularization Datasets Augmentation Diffusion Autoregression Applications Machine learning In-context learning Artificial neural network Deep learning Scientific computing Artificial Intelligence Language model Large language model Hardware IPU TPU VPU Memristor SpiNNaker Software libraries TensorFlow PyTorch Keras Theano JAX Flux.jl Implementations Audio–visual AlexNet WaveNet Human image synthesis HWR OCR Speech synthesis Speech recognition Facial recognition AlphaFold DALL-E Midjourney Stable Diffusion Whisper Verbal Word2vec Seq2seq BERT LaMDA Bard NMT Project Debater IBM Watson GPT-1 GPT-2 GPT-3 GPT-4 ChatGPT GPT-J Chinchilla AI PaLM BLOOM LLaMA Decisional AlphaGo AlphaZero Q-learning SARSA OpenAI Five Self-driving car MuZero Action selection Auto-GPT Robot control People Yoshua Bengio Alex Graves Ian Goodfellow Stephen Grossberg Demis Hassabis Geoffrey Hinton Yann LeCun Fei-Fei Li Andrew Ng Jürgen Schmidhuber David Silver Ilya Sutskever Organizations Anthropic EleutherAI Google DeepMind Hugging Face OpenAI Meta AI Mila MIT CSAIL Architectures Neural Turing machine Differentiable neural computer Transformer Recurrent neural network (RNN) Long short-term memory (LSTM) Gated recurrent unit (GRU) Echo state network Multilayer perceptron (MLP) Convolutional neural network Residual neural network Autoencoder Variational autoencoder (VAE) Generative adversarial network (GAN) Graph neural network Portals Computer programming Technology Categories Artificial neural networks Machine learning v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System.
Hardware Printed circuit board Peripheral Integrated circuit Very Large Scale Integration Systems on Chip (SoCs) Energy consumption (Green computing) Electronic design automation Hardware acceleration Computer systems organization Computer architecture Embedded system Real-time computing Dependability Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control variable Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human–computer interaction Interaction design Social computing Ubiquitous computing Visualization Accessibility Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Mixed reality Virtual reality Image compression Solid modeling Applied computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Category Outline WikiProject Commons Reinforcement learning Markov models Belief revision CS1 maint: location missing publisher CS1 maint: multiple names: authors list Articles with short description Short description matches Wikidata Wikipedia articles needing clarification from January 2020 Articles needing additional references from October 2022 All articles needing additional references Webarchive template wayback links This page was last edited on 26 October 2023, at 19:01 (UTC).
Text is available under the Creative Commons Attribution-ShareAlike License 4.0 ; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy.
 Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc.
, a non-profit organization.
Privacy policy About Wikipedia Disclaimers Contact Wikipedia Code of Conduct Developers Statistics Cookie statement Mobile view Toggle limited content width
