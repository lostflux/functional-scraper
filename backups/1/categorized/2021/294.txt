Entangling logical qubits with lattice surgery | Nature
2021
https://doi.org/10.1038%2Fs41586-020-03079-6

Thank you for visiting nature.com. You are using a browser version with limited support for CSS. To obtain the best experience, we recommend you use a more up to date browser (or turn off compatibility mode in Internet Explorer). In the meantime, to ensure continued support, we are displaying the site without styles and JavaScript.
Advertisement View all journals Search Log in Explore content About the journal Publish with us Sign up for alerts RSS feed nature articles article Download PDF Article Published: 13 January 2021 Entangling logical qubits with lattice surgery Alexander Erhard ORCID: orcid.org/0000-0002-5020-2271 1 na1 , Hendrik Poulsen Nautrup 2 na1 , Michael Meth 1 , Lukas Postler 1 , Roman Stricker ORCID: orcid.org/0000-0001-8001-1487 1 , Martin Stadler 3 , Vlad Negnevitsky 3 , Martin Ringbauer 1 , Philipp Schindler ORCID: orcid.org/0000-0002-9461-9650 1 , Hans J. Briegel 2 , 4 , Rainer Blatt 1 , 5 , Nicolai Friis ORCID: orcid.org/0000-0003-1950-8640 2 , 6 & … Thomas Monz ORCID: orcid.org/0000-0001-7410-4804 1 , 7 Show authors Nature volume 589 , pages 220–224 ( 2021 ) Cite this article 8658 Accesses 53 Citations 161 Altmetric Metrics details Subjects Quantum information Qubits Abstract The development of quantum computing architectures from early designs and current noisy devices to fully fledged quantum computers hinges on achieving fault tolerance using quantum error correction 1 , 2 , 3 , 4.
 However, these correction capabilities come with an overhead for performing the necessary fault-tolerant logical operations on logical qubits (qubits that are encoded in ensembles of physical qubits and protected by error-correction codes) 5 , 6 , 7 , 8.
 One of the most resource-efficient ways to implement logical operations is lattice surgery 9 , 10 , 11 , where groups of physical qubits, arranged on lattices, can be merged and split to realize entangling gates and teleport logical information. Here we report the experimental realization of lattice surgery between two qubits protected via a topological error-correction code in a ten-qubit ion-trap quantum information processor. In this system, we can carry out the necessary quantum non-demolition measurements through a series of local and entangling gates, as well as measurements on auxiliary qubits. In particular, we demonstrate entanglement between two logical qubits and we implement logical state teleportation between them. The demonstration of these operations—fundamental building blocks for quantum computation—through lattice surgery represents a step towards the efficient realization of fault-tolerant quantum computation.
You have full access to this article via your institution.
Download PDF Download PDF Main The basis of quantum error correction (QEC) is storing and manipulating quantum information using logical qubits. A number of experiments have demonstrated significant technological progress towards QEC 12 , 13 , 14 , 15 , including the creation of non-trivial QEC codes 16 , 17 , error detection 18 , 19 , 20 , correction of errors 21 , 22 , 23 , 24 and qubit loss 25 , and operations on one 26 , 27 , 28 , 29 , 30 , 31 and on two logical qubits in non-topological codes 32 , 33.
The most promising road towards QEC is offered by topological codes, such as the surface code 34 , 35 , which require only short-range interactions in two-dimensional (2D) architectures 28 , 36 , 37.
 Nevertheless, the implementation of encoded operations remains a major challenge. Performing arbitrary logical operations requires costly techniques such as transversal gates 5 , teleported gates 6 , magic state distillation 8 and complex optimization 38 , 39.
 Recent theoretical advances 9 , 10 in lattice surgery (LS) 11 include methods to reduce this complexity 40 while maintaining 2D layouts. In LS, the QEC code itself is altered by merging and splitting initially separate encodings, rather than by operating on all physical qubits. Such modifications can be used to manipulate logical qubits efficiently, or to adapt the robustness to different noise processes 41.
 LS further enables entanglement generation between logical qubits and can be complemented with measurement-based protocols 42 , 43 for logical state teleportation and manipulation 9.
 Here we report the experimental implementation of LS using 10 trapped ions to entangle two logical qubits encoded in two four-qubit surface codes 35.
Surface code One of the most prominent examples of a QEC code is the surface code 34 , 35 , which has error thresholds of up to 44 1%. The surface code has a simple description within the stabilizer formalism 5 , as we discuss in the following. Note that we work with qubits, that is, two-level quantum systems whose state space is defined by Pauli operators σ x , σ y , σ z and the 2 × 2 identity matrix, which form a basis of the vector space of 2 × 2 Hermitian matrices. Here, we label Pauli matrices by X , Y , Z and associate a single physical qubit with them. More generally, we can identify a single logical qubit within a composite system of many physical qubits by defining tensor products of Pauli operators X L , Y L , Z L , which obey the same commutation relation as X , Y , Z.
 This notion of logical operators ℒ = { X L , Y L , Z L } is used in QEC to define an encoding of a logical qubit in many physical qubits. We refer the reader to Methods for a more detailed introduction.
Here we consider the minimal instance of a surface code—a four-qubit code encoding a single logical qubit—as the central component of our experimental implementation. The code can be represented graphically, where the physical qubits are the vertices of a 2 × 2 bicolourable lattice, as shown in Fig.
1A, a (row ‘Schematic’, column ‘Encoded’) for two initially separate logical qubits labelled A and B. Depending on the colour, faces are associated with products of either Pauli- X or Pauli- Z operators of the adjacent physical qubits. In Fig.
1A, a (Schematic, Encoded) for example, the central, orange plaquettes can be associated with operators X 1 X 2 X 3 X 4 and X 5 X 6 X 7 X 8.
 The resulting operators are called stabilizers and form a set (group) of operations—the stabilizer code \({{\mathcal{S}}}^{{\rm{A}}/{\rm{B}}}\) —under multiplication, $$\begin{array}{c}{{\mathcal{S}}}^{{\rm{A}}}=\langle {S}_{1}^{{\rm{A}}},{S}_{2}^{{\rm{A}}},{S}_{3}^{{\rm{A}}}\rangle =\langle -\,{Z}_{1}{Z}_{2},-\,{Z}_{3}{Z}_{4},+\,{X}_{1}{X}_{2}{X}_{3}{X}_{4}\rangle ,\\ {{\mathcal{S}}}^{{\rm{B}}}=\langle {S}_{1}^{{\rm{B}}},{S}_{2}^{{\rm{B}}},{S}_{3}^{{\rm{B}}}\rangle =\langle -\,{Z}_{5}{Z}_{6},-\,{Z}_{7}{Z}_{8},+\,{X}_{5}{X}_{6}{X}_{7}{X}_{8}\rangle .\end{array}$$ Experimental results and schematics for LS between Z -type boundaries implementing a logical joint measurement \({M}_{{\rm{XX}}}^{+}\propto {\mathbb{I}}+{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) to generate a logical Bell state. We use the error detection capabilities of the code and post-select measurements with valid code stabilizers, which are presented in light coloured bars. Error bars indicate the standard deviation of the measured expectation values. We verify the code stabilizers S i by estimating the expectation value ⟨ S i ⟩ = p + − p − , where p ± is the probability of finding the encoded state in a ±1 eigenstate of S i.
A , Encoded. Two surface codes ( a ) defined on 2 × 2 lattices with average code stabilizer values ( b ) of ⟨ | S i | ⟩ = 0.868(4) (error is calculated from individual stabilizer errors) where X -stabilizers and Z -stabilizers in equation ( 1 ) are associated with orange and aquamarine faces, respectively. We observe (raw|post-selected) state fidelities ( c ) \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.8(4)|99.3(2){\rm{ \% }}\) and \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=93.4(5)|99.4(2){\rm{ \% }}\) for the encodings \(|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle \) , \(|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , respectively. Logical operators are products of Pauli operators connecting opposite boundaries (see equation ( 2 )).
B , Merged. The stabilizers \({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\) along the boundaries ( a ) are measured (dark red) using auxiliary qubits A 1 , A 2.
 This is done such that we obtain an eigenstate of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}={S}_{6}^{{\rm{M}}}{S}_{7}^{{\rm{M}}}\).
 Note that we use syndrome qubits (A 1 , A 2 ) only for merging and splitting, not for error detection. The merged code (equation ( 3 )) encodes a single logical qubit \(|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle \) corresponding to the logical operator \({Z}_{{\rm{L}}}^{{\rm{M}}}={Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) in equation ( 4 ). We observe average stabilizer values ( b ) of ⟨ | S i | ⟩ = 0.669(8), and logical state fidelities ( c ) \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle )=86.4(1.0)|97.9(5){\rm{ \% }}\).
C , Split. In order to split the merged code ( a ) while preserving the eigenstate of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) , one boundary stabilizer \({S}_{2}^{{\rm{A}}}\) of the original code is measured (green) reusing auxiliary qubit A 1 and the associated syndrome is observed. In this way, we recover the original codes with average stabilizer values ( b ) of ⟨ | S i | ⟩ = 0.603(3) which are now in a logical Bell state \(|{\varphi }_{{\rm{L}}}^{+}\rangle \) with fidelity ( c ) \( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=58.0(1.6)|75.3(1.6){\rm{ \% }}\).
Full size image Note that we choose a negative sign for some stabilizers because this is advantageous for our implementation. The logical states \(|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle \) spanning the respective code spaces for A and B are defined as the simultaneous +1 eigenstates of all stabilizers, that is, \({S}_{i}^{{\rm{A}}/{\rm{B}}}|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle =|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle \) , ∀ i ∈ {1, 2, 3}. Therefore, we find that each surface encodes a single logical qubit in two codewords, \(|{0}_{{\rm{L}}}\rangle =\frac{1}{\sqrt{2}}(|0101\rangle +|1010\rangle )\) and \(|{1}_{{\rm{L}}}\rangle =\frac{1}{\sqrt{2}}(|1001\rangle +|0110\rangle )\).
Logical operators map codewords to codewords. For instance, a logical bit-flip operator \({X}_{{\rm{L}}}^{{\rm{A}}}={X}_{1}{X}_{2}\) maps \(|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle \) to \(|{1}_{{\rm{L}}}^{{\rm{A}}}\rangle \).
 In the stabilizer formalism, logical X - and Z -operators anti-commute with each other (that is, they obey the Pauli commutation relations) and commute with all stabilizers. For example, \({X}_{{\rm{L}}}^{{\rm{A}}}\) anti-commutes with the logical phase-flip operator \({Z}_{{\rm{L}}}^{{\rm{A}}}={Z}_{1}{Z}_{3}\) but commutes with \({S}_{1}^{{\rm{A}}}\).
 These operators are defined up to multiplication with other logical operators, stabilizers and the imaginary unit i. That is, the sets of logical operators are defined as $$\begin{array}{c}{ {\mathcal L} }^{{\rm{A}}}=\langle {\rm{i}},{Z}_{{\rm{L}}}^{{\rm{A}}},{X}_{{\rm{L}}}^{{\rm{A}}}\rangle /{{\mathcal{S}}}^{{\rm{A}}}=\langle {\rm{i}},{Z}_{1}{Z}_{3},{X}_{1}{X}_{2}\rangle /{{\mathcal{S}}}^{{\rm{A}}},\\ { {\mathcal L} }^{{\rm{B}}}=\langle {\rm{i}},{Z}_{{\rm{L}}}^{{\rm{B}}},{X}_{{\rm{L}}}^{{\rm{B}}}\rangle /{{\mathcal{S}}}^{{\rm{B}}}=\langle {\rm{i}},{Z}_{5}{Z}_{7},{X}_{5}{X}_{6}\rangle /{{\mathcal{S}}}^{{\rm{B}}},\end{array}$$ where \(\langle {P}_{{\rm{L}}}\rangle /{\mathcal{S}}\) indicates that logical Pauli operators P L form equivalence classes defined up to multiplication with stabilizers (see Methods ). The logical Y -operator is determined as Y L = i Z L X L and we find \({Y}_{{\rm{L}}}^{{\rm{A}}}={Y}_{1}{X}_{2}{Z}_{3}\) and \({Y}_{{\rm{L}}}^{{\rm{B}}}={Y}_{5}{X}_{6}{Z}_{7}\).
In the stabilizer formalism, errors can be associated with finding an eigenvalue −1 when measuring a stabilizer operator. To see this, consider a bit-flip error represented by X 1 which can be detected by extracting the eigenvalue of \({S}_{1}^{{\rm{A}}}\) , \({S}_{1}^{{\rm{A}}}{X}_{1}|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle =-\,{X}_{1}|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle \).
 This eigenvalue, or error syndrome, can be obtained by measuring an auxiliary qubit (or syndrome qubit) encoding the ±1 eigenvalue of the associated stabilizer. Scaling the surface code to detect and correct more errors is, in theory, as simple as scaling the lattice (see Methods ).
Lattice surgery LS 11 is a fault-tolerant protocol for entangling QEC codes that is ideally suited to the geometry of 2D topological codes such as the surface code. This is because LS between topological codes requires only local, few-body interactions. LS 11 was introduced as a method to project two surface codes \({{\mathcal{S}}}^{{\rm{A}}}\) and \({{\mathcal{S}}}^{{\rm{B}}}\) with logical operators \({X}_{{\rm{L}}}^{{\rm{A}}}\) , \({Z}_{{\rm{L}}}^{{\rm{A}}}\) and \({X}_{{\rm{L}}}^{{\rm{B}}}\) , \({Z}_{{\rm{L}}}^{{\rm{B}}}\) , respectively, onto joint eigenstates of either \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) or \({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) , referred to as Z -type and X -type LS, respectively. These projections are entangling operations and can be used to construct entangling gates. To clarify the notation, note that the lattice boundaries of surface codes can be distinguished by their associated stabilizers: Z -type stabilizers along the boundary define one type of boundary while X -type stabilizers define another. Similarly, we label different types of LS by the boundary type they operate on. Here, we proceed by describing Z -type LS for the minimal 2 × 2 surface code discussed before, and refer to Methods for a more general introduction and details.
In order to project onto a logical eigenstate of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) , we perform a logical joint measurement \({M}_{{\rm{XX}}}^{\pm }=({\mathbb{I}}\pm {X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\) , which can be used to entangle two logical qubits, and where \({\mathbb{I}}\) is the logical two-qubit identity matrix. To achieve this, LS proceeds in two steps: merging and splitting. This procedure is illustrated in Fig.
1B, a (Schematic, Merged) and Fig.
1C, a (Schematic, Split) for two 2 × 2 surface codes \({{\mathcal{S}}}^{{\rm{A}}}\) and \({{\mathcal{S}}}^{{\rm{B}}}\).
 We first merge the two separate codes \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\) into a new stabilizer code \({{\mathcal{S}}}^{{\rm{M}}}\) by measuring merging stabilizers \({S}_{6}^{{\rm{M}}}={X}_{3}{X}_{5}\) and \({S}_{7}^{{\rm{M}}}={X}_{4}{X}_{6}\) between the boundaries. These stabilizers commute with all stabilizers of the original codes except \({S}_{2}^{{\rm{A}}}\) and \({S}_{1}^{{\rm{B}}}\) , and are chosen such that their joint measurement corresponds to the joint logical measurement \({M}_{{\rm{XX}}}^{\pm }\) , that is, \({S}_{6}^{{\rm{M}}}{S}_{7}^{{\rm{M}}}={X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\).
 As a result, we obtain the new code by discarding all stabilizers that anti-commute with the merging stabilizers, depicted in Fig.
1B, a (Schematic, Merged), $$\begin{array}{cc}{{\mathcal{S}}}^{{\rm{M}}} & =\langle {S}_{1}^{{\rm{M}}},{S}_{2}^{{\rm{M}}},{S}_{3}^{{\rm{M}}},{S}_{4}^{{\rm{M}}},{S}_{5}^{{\rm{M}}},{S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\rangle \\ & =\langle {S}_{1}^{{\rm{A}}},{S}_{3}^{{\rm{A}}},{S}_{2}^{{\rm{B}}},{S}_{3}^{{\rm{B}}},{S}_{2}^{{\rm{A}}}{S}_{1}^{{\rm{B}}},+\,{X}_{3}{X}_{5},+\,{X}_{4}{X}_{6}\rangle .\end{array}$$ Note that this code already encodes the desired joint eigenstate since \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) is included as a stabilizer in the merged code \({{\mathcal{S}}}^{{\rm{M}}}\).
 In fact, the measurement outcomes m , m ′ ∈ {0, 1} of \({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\) , respectively, are random such that m 1 = m + m ′ specifies the eigenvalue associated with \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) as \({(-1)}^{{{m}}_{1}}\).
 The merged code is an asymmetric 2 × 4 surface code encoding a single logical qubit, that is, $${ {\mathcal L} }^{{\rm{M}}}=\langle {\rm{i}},{Z}_{{\rm{L}}}^{{\rm{M}}},{X}_{{\rm{L}}}^{{\rm{M}}}\rangle /{{\mathcal{S}}}^{{\rm{M}}}=\langle {\rm{i}},{Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}},{X}_{{\rm{L}}}^{{\rm{A}}}\rangle /{{\mathcal{S}}}^{{\rm{M}}},$$ and \({Y}_{{\rm{L}}}^{{\rm{M}}}={Y}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\).
With the Z -type merge we effectively merged the logical Z -operators and performed the desired logical joint measurement \({M}_{{\rm{XX}}}^{\pm }\).
 Its expectation value ±1 is given by the product of the expectation values of merging stabilizers \({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\).
 Now, we must recover the two initial logical qubits while keeping the previously obtained expectation value of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\).
 To this end, we split the merged code by measuring Z -stabilizers \({S}_{2}^{{\rm{A}}}\) or \({S}_{1}^{{\rm{B}}}\) along the merged boundaries as depicted in Fig.
1C, a (Schematic, Split). These operators commute with all stabilizers in \({{\mathcal{S}}}^{{\rm{M}}}\) that define the separated logical qubits \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\).
 In particular, the measured stabilizers all commute with \({X}_{{\rm{L}}}^{{\rm{A}}}\) , \({X}_{{\rm{L}}}^{{\rm{B}}}\) , that is, the code remains in an eigenstate of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\).
 After splitting, measurement outcomes m ″, m ″′ ∈ {0, 1} of stabilizers \({S}_{2}^{{\rm{A}}}\) , \({S}_{1}^{{\rm{B}}}\) , respectively, are random but can be tracked as errors. In conclusion, we have effectively performed a logical entangling operation, \({M}_{{\rm{XX}}}^{\pm }\) , which can be used to entangle logical qubits and teleport information. Note that the scheme presented here differs from the original proposal 11 in that it removes the necessity of additional data qubits along the boundary 4 , 9 , 40.
 Although this change generally does not affect fault tolerance and code distance 9 , it might alter the QEC capabilities of the underlying code by effectively changing the lattice on which the surface code is defined.
LS can further be used to realize a measurement-based scheme for logical state teleportation 9.
 In Fig.
2 , we illustrate this scheme for a logical \({M}_{{\rm{XX}}}^{\pm }\) measurement on two 5 × 5 surface codes. We use 5 × 5 surface codes in this theoretical example to exemplify how LS scales with increasing system size. The merging and splitting operations used to experimentally teleport quantum information between two 2 × 2 surface codes are illustrated in Fig.
1.
 Note that a similar scheme can be used to teleport information through a logical \({M}_{{\rm{ZZ}}}^{\pm }\) measurement (see Methods ).
We illustrate the theoretical state teleportation protocol between two 5 × 5 surface codes ( a ) to exemplify the general concept of lattice surgery for larger system sizes. The merging and splitting operations for state teleportation between two 2 × 2 surface codes, as experimentally implemented in this work, is depicted in Fig.
1.
b , Measurement-based scheme to teleport information of an arbitrary logical state | ψ L ⟩ = α |0 L ⟩ + β |1 L ⟩ between two logical qubits using only single-qubit and two-qubit measurements. We start with a logical state \(|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle \) encoded in a 5 × 5 surface code and an additional logical qubit in the state \(|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \).
c , We perform LS, that is, merging and splitting, to implement a joint measurement \({M}_{{\rm{XX}}}^{{{m}}_{1}}\) , where m 1 = 0, 1 labels measurement outcomes. The resulting state is entangled.
d , Measuring the initial code in the logical Z -basis (that is, measuring all physical qubits in the Z -basis) with measurement outcome m 2 = 0, 1 teleports the logical information to the logical qubit B. Depending on the measurement outcomes m 1 , m 2 = 0, 1, logical Pauli corrections need to be considered.
Full size image Results We demonstrate LS in an ion-trap quantum computer, based on atomic 40 Ca + ions in a linear Paul trap 45.
 Each qubit is encoded in the |0 ⟩ = |4S 1/2 ( m j = −1/2) ⟩ and |1 ⟩ = |3D 5/2 ( m j = −1/2) ⟩ state of a single ion. Each experiment consists of (i) laser cooling and state preparation, (ii) coherent manipulation of the qubit states, and (iii) readout. (i) For cooling close to the motional ground state, we employ a three-stage process comprising Doppler cooling, polarization gradient cooling 46 and resolved sideband cooling followed by optical pumping into |0 ⟩.
 (ii) The qubits are manipulated with a laser at 729 nm. The available gate set includes single-qubit Z -rotations, multi-qubit X - and Y -rotations and a multi-qubit entangling Mølmer–Sørensen (MS) gate. (iii) Qubit states are read out via electron-shelving. We utilize spectroscopic decoupling to perform operations selectively on a subset of ions by coherently shelving populations from |0 ⟩ = |4 S 1/2 ( m j = −1/2) ⟩ to |3 D 5/2 ( m j = −3/2) ⟩ and from |1 ⟩ = |3 D 5/2 ( m j = −1/2) ⟩ to |3 D 5/2 ( m j = +1/2) ⟩.
 For more details we refer to Supplementary Information.
In Fig.
1 , we demonstrate LS to entangle logical qubits along the Z -type boundary. Complementary results for X -type lattice surgery are provided in Methods. We start by encoding the separated logical qubits, each defined by three stabilizers (see equation ( 1 )) and two logical operators (see equation ( 2 )) in Fig.
1A (Encoded). As a first example, we choose to encode the logical qubits in the state \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \).
 We can create encoded states with average stabilizer expectation values of ⟨ | S i | ⟩ = 0.868(4), see Fig.
1A, b (Code stabilizers, Encoded). We make use of the obtained stabilizer information and post-select our data on states with valid code stabilizers (see Supplementary Information ), which amounts to discarding those measurements where an error was detected by the code. For the encoded states we infer fidelities of \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.8(4)|99.3(2){\rm{ \% }}\) and \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=93.4(5)|99.4(2){\rm{ \% }}\) , where the first value describes the raw fidelity and the second represents the observed fidelity after post-selection; we use this format throughout this work to present fidelities of both uncorrected and post-selected data. Note that this post-selection introduces a finite survival probability (see Supplementary Information ).
Performing LS requires quantum-non-demolition (QND) measurements of stabilizers implemented by series of local and entangling gates. Considering two merging stabilizers mapped onto auxiliary qubits A 1 and A 2 , respectively, we have the possibility of detecting one of four possible outcomes ( m , m ′) = (0, 0), (0, 1), (1, 0), (1, 1). In Supplementary Information , we present data for all possible outcomes for the chosen input state. For experimental simplicity, the following results are for the case ( m , m ′) = (0, 0). The merged surface code, as defined in equation ( 3 ), is illustrated in Fig.
1B, b (Code stabilizers, Merged). The data confirm the merged stabilizers with an average stabilizer expectation value of ⟨ | S i | ⟩ = 0.669(8). Starting from the state \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , the merged logical state is a +1 eigenstate of the logical \({Z}_{{\rm{L}}}^{{\rm{M}}}={Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) operator, as can be seen in Fig.
1B, c (Logical operators, Merged). The data reveal a state fidelity of \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle )=86.4(1.0)|97.9(5){\rm{ \% }}\) after merging.
Now, we split the merged logical qubit along the same boundary by mapping \({S}_{2}^{{\rm{A}}}\) onto auxiliary qubit A 1 for the case m ″ = 0. Thereby, we restore the initial code space with an average stabilizer expectation value of ⟨ | S i | ⟩ = 0.603(3), shown in Fig.
1C, b (Code stabilizers, Split). The resulting projective measurement \(({\mathbb{I}}+{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\) maps the initial product state \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) onto a maximally entangled, logical Bell state \(|{\varphi }_{{\rm{L}}}^{+}\rangle =\frac{1}{\sqrt{2}}(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle +|{1}_{{\rm{L}}}^{{\rm{A}}}{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )\).
 In order to deduce the fidelity of the generated state with respect to the logical Bell state, we measure the common logical stabilizers \(\langle {Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}},{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}},-\,{Y}_{{\rm{L}}}^{{\rm{A}}}{Y}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , obtaining the fidelity 47 $$ {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=\frac{1}{4}(1+\langle {Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\rangle +\langle {X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\rangle -\langle {Y}_{{\rm{L}}}^{{\rm{A}}}{Y}_{{\rm{L}}}^{{\rm{B}}}\rangle ).$$ In Fig.
1C (Split), we present the results for the Bell state generation. From the common stabilizer measurements, we infer a logical Bell state fidelity of \( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=58.0(1.6)|75.3(1.6){\rm{ \% }}\) , where the raw fidelity exceeds the separability limit of 50% by 5 standard deviations. Imperfect physical gate implementations can be characterized 48 and match our expectations, as discussed in Supplementary Information.
 In Supplementary Information , we also demonstrate LS for various input states in order to generate different maximally entangled Bell states.
LS enables the teleporting of quantum states from one logical qubit to another (see Fig.
2 ), which we demonstrate for the input states \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , \(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) and \(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \).
 After performing Z -type LS (that is, encoding, merging, splitting), we measure logical qubit A in the Z -basis and apply a logical X L gate on qubit B if qubit A was found in \(|{1}_{{\rm{L}}}^{{\rm{A}}}\rangle \) (see Fig.
3 ). Following the teleportation protocol, we measure logical state fidelities for qubit B of \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=87(2)|97(1){\rm{ \% }}\) , \( {\mathcal F} (|{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )=81(2)|93(2){\rm{ \% }}\) and \( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{B}}}\rangle )=71(1)|85(2){\rm{ \% }}\) , given the input states \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , \(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) and \(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , respectively.
a , Measurement-based scheme to teleport information of an arbitrary logical state | ψ L ⟩ = α |0 L ⟩ + β |1 L ⟩ between two logical qubits (same as Fig.
2b ). We prepare the logical qubits A, B in the states \(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) , \(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) and \(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \) ( b – d , respectively), and use LS to teleport the state from logical qubit A to logical qubit B as illustrated in Fig.
2.
 We measure fidelities of the teleported quantum states of \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=87(2)|97(1){\rm{ \% }}\) \( {\mathcal F} (|{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )=81(2)|93(2){\rm{ \% }}\) and \( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{B}}}\rangle )=71(1)|85(2){\rm{ \% }}\) ( e – g , respectively).
Full size image Conclusion We have demonstrated entanglement generation and teleportation via LS between two logical qubits, each encoded in a four-qubit surface code, on a 10-qubit ion-trap quantum information processor. We have implemented both the Z - and X -type variants of LS 9 , 35 , a technique that is considered 10 , 40 to be key for operating future fault-tolerant quantum computers. For current NISQ (noisy intermediate-scale quantum)-era devices, certification of logical entanglement 49 generated via LS can provide the means of benchmarking. Besides increasing the numbers of physical and logical qubits, future challenges lie in the implementation of LS between arbitrary topological codes 9 to exploit different features, such as transversal gate implementation or high noise tolerance of the respective codes. In this way, LS can function as a fault-tolerant interface between quantum memories and quantum processors.
Methods Stabilizer quantum error correction Quantum error correction (QEC) deals with the encoding and protection of quantum information stored in quantum systems. The simplest such systems are qubits, two-level (for example, spin- \(\frac{1}{2}\) ) systems, whose degrees of freedom can be represented by the Pauli matrices $${\sigma }_{x}=(\begin{array}{cc}0 & 1\\ 1 & 0\end{array}),\,{\sigma }_{y}=(\begin{array}{cc}0 & -{\rm{i}}\\ {\rm{i}} & 0\end{array}),\,{\sigma }_{z}=(\begin{array}{cc}1 & 0\\ 0 & -1\end{array}).$$ Pauli matrices, in conjunction with the identity \({\mathbb{I}}\) , form a basis of the vector space of 2 × 2 Hermitian matrices, and so an arbitrary single-qubit density matrix ρ can be parameterized as \(\rho =\frac{1}{2}\,({\mathbb{I}}+{\bf{a}}\cdot {\boldsymbol{\sigma }})\) where \({\bf{a}}\in {{\mathbb{R}}}^{3}\) is the so-called Bloch vector and \({\boldsymbol{\sigma }}={({\sigma }_{x},{\sigma }_{y},{\sigma }_{z})}^{{\rm{T}}}\).
 Qubits can therefore be described by Pauli observables. For example, instead of writing |0 ⟩ ⟨ 0|, we may write ( \({\mathbb{I}}\) + Z )/2 where we use X , Y , Z as shorthand for Pauli matrices σ x , σ y , σ z and |0 ⟩ , |1 ⟩ are the two eigenstates of Z with eigenvalues ±1, respectively.
Interestingly, there are various ways of encoding a logical qubit in composite systems. Specifically, we may encode a qubit in either single- or multi-qubit observables. To see this, consider a pure two-qubit system ℂ 2 ⊗ ℂ 2 = span({|00 ⟩ , |01 ⟩ , |10 ⟩ , |11 ⟩ }). Let us now fix the second qubit to the +1 eigenstate of Z 2 (that is, |0 ⟩ 2 ). Since this is a composite system, the eigenvalue is degenerate and we can define a single qubit by span({|0 ⟩ 1 , |1 ⟩ 1 }) where subscripts label qubits. However, we may also fix the composite system to the +1 eigenstate of Z 1 Z 2.
 We then can still define a qubit by span({|00 ⟩ , |11 ⟩ }). This qubit is associated with a new set of logical Pauli observables { X L , Y L , Z L } = { X 1 X 2 , Y 1 X 2 , Z 1 }, which obey the same commutation relation as X 1 , Y 1 , Z 1.
 This notion of encoding qubits in composite systems is used in QEC to protect quantum information.
In QEC our aim is to encode a few logical qubits into many physical qubits such that redundancies can be exploited to detect and correct errors. That is, we replace single-qubit basis states |0 ⟩ , |1 ⟩ by encoded, logical states |0 L ⟩ , |1 L ⟩ that are made up by many physical qubits. Consider for instance the encoding (or codewords) |0 L ⟩ = |000 ⟩ and |1 L ⟩ = |111 ⟩ where we redundantly encoded a logical qubit into three physical (or data) qubits. This code can correct for a single-qubit X -error. To see this, consider that we observe a state |100 ⟩.
 This state is not within the code subspace {|0 L ⟩ , |1 L ⟩ } and we have to conclude that either a single-qubit error X 1 |0 L ⟩ or a two-qubit error X 2 X 3 |1 L ⟩ occurred. Under the assumption that a single-qubit error is more likely to happen than two errors on two qubits, we exclude the latter possibility by a majority vote. We can always apply this reasoning to any single-qubit error. By contrast, whenever two-qubit errors occur, our correction would fail and we would effectively introduce a logical error that maps one codeword to another, for example, \(|{0}_{{\rm{L}}}\rangle \mapsto |{1}_{{\rm{L}}}\rangle \).
 When using the Hamming distance to measure the distance between states (which is equivalent to counting the number of single-qubit Pauli operators mapping one to the other), the correction procedure as described above maps an erroneous state to the nearest codeword.
In practice, we will not be able to observe the computational state until the end of a computation. However, we need to be able to perform QEC as described above throughout the computation. Therefore, it is important to note that we can actively observe single-qubit errors in the above code without disturbing the encoded information. This is done by considering so-called code stabilizers. These are mutually commuting operators S i in the three-qubit Pauli group \({{\mathcal{P}}}_{3}\) that map the code subspace to itself while acting as identity on the encoded information, that is, S i |0 L ⟩ = |0 L ⟩ , S i |1 L ⟩ = |1 L ⟩ and [ S i , S j ] = 0. Since our code consists of three physical qubits while encoding a single logical qubit, we can expect to find two independent, commuting Pauli operators with this property. Indeed, we find S 1 = Z 1 Z 2 and S 2 = Z 2 Z 3 which can be used to generate a group \({\mathcal{S}}\) under multiplication, that is, \({\mathcal{S}}=\langle {S}_{1},{S}_{2}\rangle =\{{\mathbb{I}},{S}_{1},{S}_{2},{S}_{1}{S}_{2}\}\).
 This group is called the stabilizer group and contains all stabilizers for this codespace. Since the code subspace is an eigenspace of these operators, we can simultaneously measure all stabilizers without disturbing the logical information. Without errors, measuring stabilizers will always result in the same outcome, namely +1. However, were an error X 1 to occur, the measurement outcome of stabilizer S 1 , its so-called syndrome s 1 , would change sign since errors anti-commute with stabilizers, that is, { S 1 , X 1 } = 0. The only other combination of X -errors that could possibly lead to the syndromes s 1 = −1 and s 2 = +1 is a two-qubit error X 2 X 3.
 In practice, we collect these syndromes by measuring auxiliary qubits, so-called syndrome qubits, which encode the eigenvalues of associated stabilizers. That is, a projective stabilizer measurement can be performed by entangling data qubits with a syndrome qubit and measuring the latter. As a result, we end up with the same majority vote as before but without measuring the logical state of the encoded qubit. This is the convenience of the stabilizer formalism.
In this formalism, logical operations take a simple form as the normalizer \(N({\mathcal{S}})\subseteq {{\mathcal{P}}}_{3}\) of the stabilizer group which is the group of operators that leaves the stabilizer group invariant. We are only considering Pauli operators, and hence the normalizer is also the centralizer \(C({\mathcal{S}})\) of \({\mathcal{S}}\) which is the group of operators that commutes with all stabilizers. Since this definition includes stabilizers themselves, we define the group of logical operators as a quotient group \( {\mathcal L} =N({\mathcal{S}})/{\mathcal{S}}\) such that logical operators form equivalence classes under multiplication with stabilizers. In our case, the equivalence classes are \({[{\mathbb{I}}]}_{{\mathcal{S}}},{[{Z}_{1}]}_{{\mathcal{S}}},{[{X}_{1}{X}_{2}{X}_{3}]}_{{\mathcal{S}}}\) , that is, one for each logical operation.
QEC is done to protect encoded information from non-trivial logical errors in \( {\mathcal L} \).
 Since we are only considering products of Pauli operators, elements of \( {\mathcal L} \) are also just products of Pauli operators. This allows us to infer the minimum number of single-qubit errors composing a logical error, that is, its distance d.
 To see this, consider the non-trivial operator \({Z}_{{\rm{L}}}\in {\mathcal L} \) and its weight w ( Z L ) which is the number of non-trivial terms in the product of Pauli operators. In our example, Z L = Z 1 , that is, its weight is 1 and a single-qubit Z -error can cause a logical Z -error. In other words, the above code can tolerate no Z -errors and its distance is therefore d = 1. However, with respect to logical X -operators \({[{X}_{1}{X}_{2}{X}_{3}]}_{{\mathcal{S}}}\) , the minimum weight of any logical X -operator is 3 such that the code can correct 1 and detect 2 X -errors. Since the correction procedure is based on majority voting, a code with distance d can generally correct up to ( d − 1)/2 errors and detect up to d − 1 errors. The distance of the code is also the minimal Hamming distance between codewords, that is, the minimum required number of single-qubit Pauli operators mapping any one codeword to another.
In summary, QEC in the stabilizer formalism is active in the sense that we are required to measure stabilizers and extract syndromes throughout a quantum computation. The syndromes can then be analysed to determine by a majority vote the errors that have occurred. Logical operators are operators that commute with all stabilizers but are not stabilizers themselves.
Surface code Here we consider a general construction of surface codes in the stabilizer formalism. Consider n qubits laid out on the vertices V of a bicoloured square lattice as displayed in Extended Data Fig.
1.
 Let us associate a stabilizer with each coloured plaquette p ∈ P as follows, $${S}_{p}^{X}=\prod _{v\in {\mathcal{N}}(p)}{X}_{v}$$ $${S}_{p}^{Z}=\prod _{v\in {\mathcal{N}}(p)}{Z}_{v}$$ where \({\mathcal{N}}(p)\subseteq V\) is the set of vertices neighbouring a plaquette p and P is the set of faces.
X -stabilizers S X are placed on orange plaquettes while Z -stabilizers S Z are placed on aquamarine plaquettes. Since neighbouring plaquettes always share two vertices, stabilizers commute for all p ∈ P.
 For the lattice under consideration, there are s = n − 1 independent, commuting stabilizers. Therefore, the Hilbert space, which is the simultaneous +1 eigenspace of all stabilizers, has n − s = 1 degree of freedom. This degree of freedom is a qubit since we can define logical X L and Z L Pauli operators. In the case of the surface code, logical operators are products of Pauli operators connecting opposite boundaries of the lattice. To see this, consider a line drawn on the lattice connecting top and bottom boundaries, as indicated by dashed frames in Extended Data Fig.
1.
 Placing X -operators on vertices enclosed by this frame, we obtain an operator commuting with all stabilizers but which is not a stabilizer itself. Therefore, this operator corresponds to a logical operator X L.
 At the same time, we can analogously draw a line connecting left and right boundaries. Placing Z -operators along this line, we obtain an operator commuting with all stabilizers but anti-commuting with X L.
 Therefore, this product of Pauli- Z operators defines the logical Z -operator Z L.
 Note that the shortest line connecting opposite boundaries crosses three vertices. Therefore, the code can correct up to one single-qubit error and has distance d = 3.
In order to perform QEC, we continuously measure the code stabilizers. Whenever a stabilizer measurement result, that is, its syndrome, changes sign from +1 to −1, we have detected an error. Assuming that less than ( d − 1)/2 errors have occurred, we can associate with each syndrome a correction procedure which recovers the state of all +1 stabilizers from the erroneous state without causing a logical error.
Lattice surgery Here, we consider lattice surgery (LS) in general as a method to project onto a joint eigenstate of logical Pauli operators. That is, LS maps two stabilizer QEC codes \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\) onto a joint eigenstate \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\) of two logical Pauli operators of the codes. This is achieved through a joint measurement \({M}_{P\mathop{P}\limits^{ \sim }}^{\pm }=({\mathbb{I}}\pm {P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}})/2\) which can be implemented fault-tolerantly. Note that an operation is called fault-tolerant if errors during the operation can only map to a constant number of physical qubits in the encoding independent of the code size. In Extended Data Fig.
2 , we illustrate how joint Pauli measurements as described above can be used to implement logical CNOT and Hadamard H gates as well as code teleportation through a measurement-based scheme.
LS itself proceeds in two steps: merging and splitting. In order to initialize a measurement \({M}_{P\mathop{P}\limits^{ \sim }}^{\pm }\) , we first merge the two separated codes \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\) into a new stabilizer code \({{\mathcal{S}}}^{M}\) by projecting onto a joint eigenstate \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\).
 In order for this to be fault-tolerant, we measure a number of so-called merging stabilizers \({\{{S}_{i}^{M}\}}_{i}\) across the boundary such that \({\prod }_{i}{S}_{i}^{M}={P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\).
 This is displayed for the surface code in Extended Data Fig.
3 where we consider \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\) to be 2 × 2 surface codes and \({P}_{{\rm{L}}}={\mathop{P}\limits^{ \sim }}_{{\rm{L}}}={X}_{{\rm{L}}},{Z}_{L}\) , respectively. Then, the merged code is just a new surface code on an asymmetric lattice and the merging stabilizers are just surface code stabilizers at the interface between the two codes. Stabilizers at the boundary that do not commute with the merging stabilizers are discarded from the stabilizer group and only the product of boundary operators remain since they commute. Notably, the merged code encodes only a single logical qubit and \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\) is contained as a stabilizer. That is, this procedure projects onto an eigenstate of \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\).
 Its eigenvalue ±1 is determined by the measurement outcome of the product of merging stabilizers. In order to correct for measurement errors, we need to measure \({\{{S}_{i}^{M}\}}_{i}\) d times. These errors correspond to failed measurements that yield a syndrome s although its expectation value is − s.
 Such measurement errors can be identified by comparing measurement results at different times.
Now, we want to recover the two initial logical qubits while remaining in an eigenstate of \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\).
 To this end, we split the merged code by measuring stabilizers of the separated codes \({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\) along the aligned boundaries as illustrated in Extended Data Fig.
3C rightmost column (Split). Since these stabilizers anti-commute with merging stabilizers, the set \({\{{S}_{i}^{M}\}}_{i}\) is discarded from the stabilizer groups and we recover the original two codes. However, since all stabilizers always commute with the logical operators, the resulting state remains an eigenstate of \({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\).
 At the end, QEC is required to ensure full fault-tolerance. Surface code LS usually distinguishes Z -type and X -type LS by association with the respective boundaries along which LS is performed. Note that Z -type and X -type LS therefore refer to a projection onto an \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) or \({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) eigenstate, respectively. Let us further point out that one may encounter a different terminology in terms of rough and smooth LS in the literature 3 , 11.
 That notation is due to a different surface code representation and may be associated with what we call Z - and X -type LS, respectively. Generally however, we do not restrict to Z -type and X -type LS alone since a projection onto \({Z}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) can be used to generate a logical Hadamard as shown in Extended Data Fig.
2.
Results of X -type LS X -type LS differs from Z -type LS as described in the main text only in so far that both codes are considered to be rotated by 90° before LS. Equivalently, one can understand X -type LS as merging and splitting along the upper/lower instead of the left/right boundaries, as illustrated in Extended Data Fig.
3b (bottom row; X -type). In the case of two 2 × 2 surface codes, measuring the merging stabilizer \(\bar{S}{}_{7}^{{\rm{M}}}={Z}_{2}{Z}_{4}{Z}_{5}{Z}_{7}\) , we obtain a 4 × 2 asymmetric surface code $$\begin{array}{cc}{\bar{{\mathcal{S}}}}^{{\rm{M}}} & =\langle {\bar{S}}_{1}^{{\rm{M}}},{\bar{S}}_{2}^{{\rm{M}}},{\bar{S}}_{3}^{{\rm{M}}},{\bar{S}}_{4}^{{\rm{M}}},{\bar{S}}_{5}^{{\rm{M}}},{\bar{S}}_{6}^{{\rm{M}}},{\bar{S}}_{7}^{{\rm{M}}}\rangle \\ & ={{\mathcal{S}}}^{{\rm{A}}}\times {{\mathcal{S}}}^{{\rm{B}}}\times \langle +\,{Z}_{2}{Z}_{4}{Z}_{5}{Z}_{7}\rangle .\end{array}$$ which can be split by discarding the merging stabilizer. It is worth noting that the merging operation already concludes the LS since the merging stabilizer is in fact \({Z}_{{\rm{L}}}^{A}\otimes {Z}_{{\rm{L}}}^{B}\).
 This is an artefact of reducing the general LS procedure as exemplified for a larger surface code in Fig.
2 to distance-two surface codes.
We present the results for the X -type LS in Extended Data Fig.
4 and report a Bell state fidelity of \( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=63.9(2.8)|78.0(2.7){\rm{ \% }}\).
 Further measurement results for various input states can be found in Supplementary Information.
Data availability The data that support the findings of this study are available at https://doi.org/10.5281/zenodo.4081412.
Code availability All codes used for data analysis are available from the corresponding authors upon reasonable request.
References Preskill, J. in Introduction to Quantum Computation (eds Lo, H.-K., Popescu, S. & Spiller, T. P.) Ch. 8, 213–269 (World Scientific, 1997).
Devitt, S. J., Munro, W. J. & Nemoto, K. Quantum error correction for beginners.
Rep. Prog. Phys.
76 , 076001 (2013).
Article ADS PubMed Google Scholar Terhal, B. M. Quantum error correction for quantum memories.
Rev. Mod. Phys.
87 , 307–346 (2015).
Article ADS MathSciNet Google Scholar Campbell, E. T., Terhal, B. M. & Vuillot, C. Roads towards fault-tolerant universal quantum computation.
Nature 549 , 172–179 (2017); correction 559 , E6 (2018).
Article ADS CAS PubMed Google Scholar Gottesmann, D.
Stabilizer Codes and Quantum Error Correction.
 Ph.D. thesis, Caltech (1997).
Gottesman, D. & Chuang, I. L. Demonstrating the viability of universal quantum computation using teleportation and single-qubit operations.
Nature 402 , 390–393 (1999).
Article ADS CAS Google Scholar Eisert, J., Jacobs, K., Papadopoulos, P. & Plenio, M. B. Optimal local implementation of nonlocal quantum gates.
Phys. Rev. A 62 , 052317 (2000).
Article ADS Google Scholar Bravyi, S. & Kitaev, A. Universal quantum computation with ideal Clifford gates and noisy ancillas.
Phys. Rev. A 71 , 022316 (2005).
Article ADS MathSciNet MATH Google Scholar Poulsen Nautrup, H., Friis, N. & Briegel, H. J. Fault-tolerant interface between quantum memories and quantum processors.
Nat. Commun.
8 , 1321 (2017).
Article ADS PubMed PubMed Central Google Scholar Gutiérrez, M., Müller, M. & Bermúdez, A. Transversality and lattice surgery: exploring realistic routes toward coupled logical qubits with trapped-ion quantum processors.
Phys. Rev. A 99 , 022330 (2019).
Article ADS Google Scholar Horsman, C., Fowler, A. G., Devitt, S. & Van Meter, R. Surface code quantum computing by lattice surgery.
New J. Phys.
14 , 123011 (2012).
Article ADS MathSciNet MATH Google Scholar Chiaverini, J. et al. Realization of quantum error correction.
Nature 432 , 602–605 (2004).
Article ADS CAS PubMed Google Scholar Boulant, N., Viola, L., Fortunato, E. M. & Cory, D. G. Experimental implementation of a concatenated quantum error-correcting code.
Phys. Rev. Lett.
94 , 130501 (2005).
Article ADS PubMed Google Scholar Zhang, J., Gangloff, D., Moussa, O. & Laamme, R. Experimental quantum error correction with high fidelity.
Phys. Rev. A 84 , 034303 (2011).
Article ADS Google Scholar Wootton, J. R. & Loss, D. Repetition code of 15 qubits.
Phys. Rev. A 97 , 052313 (2018).
Article ADS CAS Google Scholar Bell, B. A. et al. Experimental demonstration of a graph state quantum error-correction code.
Nat. Commun.
5 , 3658 (2014).
Article ADS CAS PubMed Google Scholar Takita, M., Cross, A. W., Córcoles, A. D., Chow, J. M. & Gambetta, J. M. Experimental demonstration of fault-tolerant state preparation with superconducting qubits.
Phys. Rev. Lett.
119 , 180501 (2017).
Article ADS PubMed Google Scholar Kelly, J. et al. State preservation by repetitive error detection in a superconducting quantum circuit.
Nature 519 , 66–69 (2015).
Article ADS CAS PubMed Google Scholar Linke, N. M. et al. Fault-tolerant quantum error detection.
Sci. Adv.
3 , e1701074 (2017).
Article ADS PubMed PubMed Central Google Scholar Andersen, C. K. et al. Repeated quantum error detection in a surface code.
Nat. Phys.
16 , 875–880 (2020).
Article CAS Google Scholar Aoki, T. et al. Quantum error correction beyond qubits.
Nat. Phys.
5 , 541–546 (2009).
Article CAS Google Scholar Reed, M. D. et al. Realization of three-qubit quantum error correction with superconducting circuits.
Nature 482 , 382–385 (2012).
Article ADS CAS PubMed Google Scholar Waldherr, G. et al. Quantum error correction in a solid-state hybrid spin register.
Nature 506 , 204–207 (2014).
Article ADS CAS PubMed Google Scholar Ofek, N. et al. Extending the lifetime of a quantum bit with error correction in superconducting circuits.
Nature 536 , 441–445 (2016).
Article ADS CAS PubMed Google Scholar Stricker, R. et al. Experimental deterministic correction of qubit loss.
Nature 585 , 207–210 (2020).
Article PubMed Google Scholar Zhang, J., Laflamme, R. & Suter, D. Experimental implementation of encoded logical qubit operations in a perfect quantum error correcting code.
Phys. Rev. Lett.
109 , 100503 (2012).
Article ADS PubMed Google Scholar Nigg, D. et al. Quantum computations on a topologically encoded qubit.
Science 345 , 302–305 (2014).
Article ADS MathSciNet CAS MATH PubMed Google Scholar Barends, R. et al. Superconducting quantum circuits at the surface code threshold for fault tolerance.
Nature 508 , 500–503 (2014).
Article ADS CAS PubMed Google Scholar Heeres, R. W. et al. Implementing a universal gate set on a logical qubit encoded in an oscillator.
Nat. Commun.
8 , 94 (2017).
Article ADS PubMed PubMed Central Google Scholar Gong, M. et al. Experimental verification of five-qubit quantum error correction with superconducting qubits. Preprint at http://arXiv.org/abs/1907.04507 (2019).
Hu, L. et al. Quantum error correction and universal gate set operation on a binomial bosonic logical qubit.
Nat. Phys.
15 , 503–508 (2019).
Article CAS Google Scholar Chou, K. S. et al. Deterministic teleportation of a quantum gate between two logical qubits.
Nature 561 , 368–373 (2018).
Article ADS CAS PubMed Google Scholar Harper, R. & Flammia, S. T. Fault-tolerant logical gates in the IBM quantum experience.
Phys. Rev. Lett.
122 , 080504 (2019).
Article ADS CAS PubMed Google Scholar Dennis, E., Kitaev, A., Landahl, A. & Preskill, J. Topological quantum memory.
J. Math. Phys.
43 , 4452–4505 (2002).
Article ADS MathSciNet MATH Google Scholar Fowler, A. G., Mariantoni, M., Martinis, J. M. & Cleland, A. N. Surface codes: towards practical large-scale quantum computation.
Phys. Rev. A 86 , 032324 (2012).
Article ADS Google Scholar Lekitsch, B. et al. Blueprint for a microwave trapped ion quantum computer.
Sci. Adv.
3 , e1601540 (2017).
Article ADS PubMed PubMed Central Google Scholar Jones, N. C. et al. Layered architecture for quantum computing.
Phys. Rev. X 2 , 031007 (2012).
Google Scholar Herr, D., Nori, F. & Devitt, S. J. Optimization of lattice surgery is NP-hard.
npj Quantum Inf.
3 , 35 (2017).
Article ADS Google Scholar Häner, T., Steiger, D. S., Svore, K. & Troyer, M. A software methodology for compiling quantum programs.
Quantum Sci. Technol.
3 , 020501 (2018).
Article ADS Google Scholar Litinski, D. A game of surface codes: large-scale quantum computing with lattice surgery.
Quantum 3 , 128 (2019).
Article Google Scholar Nautrup, H. P., Delfosse, N., Dunjko, V., Briegel, H. J. & Friis, N. Optimizing quantum error correction codes with reinforcement learning.
Quantum 3 , 215 (2019).
Article Google Scholar Raussendorf, R. & Briegel, H. J. A one-way quantum computer.
Phys. Rev. Lett.
86 , 5188–5191 (2001).
Article ADS CAS PubMed Google Scholar Lanyon, B. P. et al. Measurement-based quantum computation with trapped ions.
Phys. Rev. Lett.
111 , 210501 (2013).
Article ADS CAS PubMed Google Scholar Wang, D. S., Fowler, A. G. & Hollenberg, L. C. L. Surface code quantum computing with error rates over 1%.
Phys. Rev. A 83 , 020302(R) (2011).
Article ADS Google Scholar Schindler, P. et al. A quantum information processor with trapped ions.
New J. Phys.
15 , 123012 (2013).
Article ADS Google Scholar Ejtemaee, S. & Haljan, P. C. 3D Sisyphus cooling of trapped ions.
Phys. Rev. Lett.
119 , 043001 (2017).
Article ADS CAS PubMed Google Scholar Friis, N. et al. Observation of entangled states of a fully controlled 20-qubit system.
Phys. Rev. X 8 , 021012 (2018).
CAS Google Scholar Erhard, A. et al. Characterizing large-scale quantum computers via cycle benchmarking.
Nat. Commun.
10 , 5347 (2019).
Article ADS PubMed PubMed Central Google Scholar Friis, N., Vitagliano, G., Malik, M. & Huber, M. Entanglement certification from theory to experiment.
Nat. Rev. Phys.
1 , 72–87 (2019).
Article Google Scholar Download references Acknowledgements We acknowledge support from the Austrian Science Fund (FWF) through SFB BeyondC (grant F71). H.P.N. and H.J.B. acknowledge support from FWF project DK-ALM (grant W1259-N27). H.J.B. was also supported by the Ministerium für Wissenschaft, Forschung, und Kunst Baden-Württemberg (AZ:33-7533.-30-10/41/1). N.F. acknowledges support from the FWF through project P 31339-N27. A.E., M.M., L.P., R.S., M.R., P.S., T.M. and R.B. acknowledge funding by the US Army Research Office (ARO) through grant no. W911NF-14-1-0103. We also acknowledge funding by the Austrian Research Promotion Agency (FFG) contract 872766, and by the EU H2020-FETFLAG-2018-03 under grant agreement no. 820495. M.S. and V.N. acknowledge funding by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), via US ARO grant no. W911NF-16-1-0070. This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement no. 801110 and the Austrian Federal Ministry of Education, Science and Research (BMBWF). We acknowledge support from the IQI GmbH. All statements of fact, opinions or conclusions contained herein are those of the authors and should not be construed as representing the official views or policies of the funding agencies.
Author information Author notes These authors contributed equally: Alexander Erhard, Hendrik Poulsen Nautrup Authors and Affiliations Institute for Experimental Physics, University of Innsbruck, Innsbruck, Austria Alexander Erhard, Michael Meth, Lukas Postler, Roman Stricker, Martin Ringbauer, Philipp Schindler, Rainer Blatt & Thomas Monz Institute for Theoretical Physics, University of Innsbruck, Innsbruck, Austria Hendrik Poulsen Nautrup, Hans J. Briegel & Nicolai Friis Institute for Quantum Electronics, ETH Zürich, Zurich, Switzerland Martin Stadler & Vlad Negnevitsky Fachbereich Philosophie, Universität Konstanz, Konstanz, Germany Hans J. Briegel Institute for Quantum Optics and Quantum Information, Austrian Academy of Sciences, Innsbruck, Austria Rainer Blatt Institute for Quantum Optics and Quantum Information – IQOQI Vienna, Austrian Academy of Sciences, Vienna, Austria Nicolai Friis Alpine Quantum Technologies GmbH, Innsbruck, Austria Thomas Monz Authors Alexander Erhard View author publications You can also search for this author in PubMed Google Scholar Hendrik Poulsen Nautrup View author publications You can also search for this author in PubMed Google Scholar Michael Meth View author publications You can also search for this author in PubMed Google Scholar Lukas Postler View author publications You can also search for this author in PubMed Google Scholar Roman Stricker View author publications You can also search for this author in PubMed Google Scholar Martin Stadler View author publications You can also search for this author in PubMed Google Scholar Vlad Negnevitsky View author publications You can also search for this author in PubMed Google Scholar Martin Ringbauer View author publications You can also search for this author in PubMed Google Scholar Philipp Schindler View author publications You can also search for this author in PubMed Google Scholar Hans J. Briegel View author publications You can also search for this author in PubMed Google Scholar Rainer Blatt View author publications You can also search for this author in PubMed Google Scholar Nicolai Friis View author publications You can also search for this author in PubMed Google Scholar Thomas Monz View author publications You can also search for this author in PubMed Google Scholar Contributions A.E., H.P.N., P.S. and N.F. wrote the manuscript and A.E., H.P.N., M.M., L.P., R.S., M.R., P.S., H.J.B., R.B., N.F. and T.M. provided revisions. A.E., H.P.N., P.S. and N.F. developed the research based on discussions with H.J.B., R.B. and T.M. H.P.N. and N.F. developed the theory. A.E. and P.S. performed the experiments. A.E., M.M., L.P., R.S., M.S., V.N., M.R., P.S., R.B. and T.M. contributed to the experimental setup. A.E., H.P.N., M.M., L.P., R.S., M.R., P.S., H.J.B., R.B., N.F. and T.M. contributed to discussions of the results and the manuscript.
Corresponding authors Correspondence to Nicolai Friis or Thomas Monz.
Ethics declarations Competing interests T.M. and R.B. are founding members of Alpine Quantum Technologies GmbH.
Additional information Peer review information Nature thanks Rodney Van Meter, Theodore Yoder and the other, anonymous, reviewer(s) for their contribution to the peer review of this work. Peer reviewer reports are available.
Publisher’s note Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.
Extended data figures and tables Extended Data Fig. 1 Standard surface code of distance 3.
The standard surface code is defined on a square lattice with (data) qubits located on vertices. Stabilizers are associated with faces and boundaries. Aquamarine faces and boundaries indicate Z -type stabilizers, as in equation ( 6 ). Red faces and boundaries indicate X -type stabilizers, as in equation ( 5 ). The surface code with boundaries encodes a single logical qubit defined by its logical Pauli- X and Pauli- Z operators. These operators are defined on paths connecting opposite boundaries of the lattice and act as products of X - and Z -operators, respectively, along the paths. Here, two representative logical operators are drawn as products of Pauli-operators within the dashed rectangles. Red indicates Pauli- X operators and green indicates Pauli- Z operators. The two operators anti-commute at the crossing drawn in yellow.
Extended Data Fig. 2 Fault-tolerant logic gates with lattice surgery.
Lattice surgery (LS) enables measurement-based implementations of logic gates and logical state teleportation. LS operations are logical joint measurements of the form \({M}_{P\mathop{P}\limits^{ \sim }}=({\mathbb{I}}\pm P\mathop{P}\limits^{ \sim })/2\) where \(P,\mathop{P}\limits^{ \sim }\) are Pauli operators. Moreover, the protocols make use of single-qubit measurements of the form M P = ( \({\mathbb{I}}\) ± P )/2. Thick lines indicate logical qubits in the circuit model and double lines represent classical bits indicating measurement outcomes m i = 0, 1. Pauli corrections need to be applied which are conditioned on the measurement outcomes as \({P}_{{\rm{L}}}^{{m}_{i}}\).
 The symbol ⊕ represents an XOR-gate between classical bits.
a , Measurement-based implementation of a logical CNOT-gate between arbitrary control and target qubits requiring an auxiliary qubit in the |+ L ⟩ state.
b , Measurement-based teleportation protocol for state teleportation between two logical qubits using X -type LS.
c , Measurement-based implementation of a logical Hadamard gate H based on the teleportation protocol.
Extended Data Fig. 3 Surface code lattice surgery in theory.
Surface code LS between Z -type and X -type boundaries implementing logical joint measurements \({M}_{{\rm{XX}}}^{\pm }=({\mathbb{I}}\pm {X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\) ( a ) and \({M}_{{\rm{ZZ}}}^{\pm }=({\mathbb{I}}\pm {Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}})/2\) ( b ), respectively.
A , Encoded. The two initial surface codes are defined on 2 × 2 lattices where X -stabilizers are associated with orange faces and Z -stabilizers with aquamarine faces in accordance with equation ( 1 ). Logical operators are products of Pauli operators connecting opposite boundaries as in equation ( 2 ).
a , Z -type encoded. The two surface codes are arranged such that they are aligned along their Z -type boundary.
b , X-type encoded. The surface codes are aligned along their X -type boundary.
B , Merged. Treating the two codes as a single (asymmetric) surface code, (merging) stabilizers along the boundaries are measured. The merged code encodes a single logical qubit corresponding to the logical Pauli operators \({X}_{{\rm{L}}}^{{\rm{M}}},{Z}_{{\rm{L}}}^{{\rm{M}}}\).
a , Z -type merged. Merging stabilizers (indicated in red) are chosen such that their product is \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\).
b , X -type merged. Merging stabilizers (indicated in green) are chosen such that their product is \({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\).
C , Split. In order to split the merged code while preserving the eigenstate of the joint logical operator, the boundary stabilizers of the original code are measured. These operators anti-commute with the merging stabilizers and thus project onto the individual codes. Since the boundary operators commute with individual logical operators, the resulting state remains an eigenstate of the joint logical operator.
a , Z -type split. Measuring Z -stabilizers along the boundary (indicated in green) preserves the eigenstate of \({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) while projecting onto the individual codes.
b , X -type split. Measuring X -stabilizers along the boundary (indicated in red) preserves the eigenstate of \({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) while projecting onto the individual codes.
Extended Data Fig. 4 Experimental X -type surface code lattice surgery.
Bell state generation via lattice surgery along the X -type boundary between two surface code qubits through a logical joint measurement \({M}_{{\rm{ZZ}}}^{+}\propto {\mathbb{I}}+{Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\).
 Post-selected measurements are presented in light coloured bars.
A , Encoded. Two logical qubits ( a ) are encoded with average stabilizer values ( b ) of ⟨ | S i | ⟩ = 0.813(4). We observe raw and post-selected state fidelities ( c ) of \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.3(5)|98.7(2){\rm{ \% }}\) for logical qubit A and \( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=92.4(5)|97.9(3){\rm{ \% }}\) for logical qubit B.
B , Merged. The two separated logical qubits are merged ( a ) into a single logical qubit by measuring the stabilizer \({S}_{7}^{{\rm{M}}}\) using auxiliary qubit A 1 as syndrome qubit. Thereby, the code space is extended in the vertical direction and the new logical operator \({X}_{{\rm{L}}}^{{\rm{M}}}={X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\) is formed. As the data show, the stabilizer \({S}_{7}^{{\rm{M}}}\) is indeed created. The average stabilizer values ( b ) are ⟨ | S i | ⟩ = 0.719(5) and logical state fidelities ( c ) are \( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{M}}}\rangle )=76.2(8)|93.1(6){\rm{ \% }}\).
C , Split. The single logical qubit is again split into two logical qubits ( a ) along the same boundary they have been initially merged through. We measure the stabilizer \(\bar{S}{}_{6}^{{\rm{M}}}\) by using auxiliary qubit A 2 as syndrome qubit to perform the splitting and obtain average stabilizer values ( b ) of ⟨ | S i | ⟩ = 0.763(5). The fidelity ( c ) of the generated state to the logical Bell state is \( {\mathcal F} (|{\psi }_{{\rm{L}}}^{+}\rangle )=63.9(2.8)|78.0(2.7){\rm{ \% }}\).
 Note that measuring the merging stabilizer \({S}_{7}^{{\rm{M}}}\) = \({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\) directly projects onto a joint eigenstate of the logical Z -operators such that the splitting becomes redundant. Nevertheless, the general procedure as described in Methods requires the measurement of X -stabilizers along the boundary which is why it is still included here.
Supplementary information Supplementary Information This file contains additional details on the performed experiment.
Peer Review File Rights and permissions Reprints and Permissions About this article Cite this article Erhard, A., Poulsen Nautrup, H., Meth, M.
et al.
Entangling logical qubits with lattice surgery.
Nature 589 , 220–224 (2021). https://doi.org/10.1038/s41586-020-03079-6 Download citation Received : 01 July 2020 Accepted : 20 October 2020 Published : 13 January 2021 Issue Date : 14 January 2021 DOI : https://doi.org/10.1038/s41586-020-03079-6 Share this article Anyone you share the following link with will be able to read this content: Sorry, a shareable link is not currently available for this article.
Provided by the Springer Nature SharedIt content-sharing initiative This article is cited by Quantum networks with neutral atom processing nodes Jacob P. Covey Harald Weinfurter Hannes Bernien npj Quantum Information (2023) Noisy intermediate-scale quantum computers Bin Cheng Xiu-Hao Deng Dapeng Yu Frontiers of Physics (2023) Demonstration of fault-tolerant universal quantum gate operations Lukas Postler Sascha Heuβen Thomas Monz Nature (2022) Versatile neutral atoms take on quantum circuits Hannah J. Williams Nature (2022) A quantum processor based on coherent transport of entangled atom arrays Dolev Bluvstein Harry Levine Mikhail D. Lukin Nature (2022) Comments By submitting a comment you agree to abide by our Terms and Community Guidelines.
 If you find something abusive or that does not comply with our terms or guidelines please flag it as inappropriate.
You have full access to this article via your institution.
Download PDF Download PDF Advertisement Explore content Research articles News Opinion Research Analysis Careers Books & Culture Podcasts Videos Current issue Browse issues Collections Subjects Follow us on Facebook Follow us on Twitter Sign up for alerts RSS feed About the journal Journal Staff About the Editors Journal Information Our publishing models Editorial Values Statement Journal Metrics Awards Contact Editorial policies History of Nature Send a news tip Publish with us For Authors For Referees Language editing services Submit manuscript Search Quick links Explore articles by subject Find a job Guide to authors Editorial policies Nature ( Nature ) ISSN 1476-4687 (online) ISSN 0028-0836 (print) nature.com sitemap About Nature Portfolio About us Press releases Press office Contact us Discover content Journals A-Z Articles by subject Nano Protocol Exchange Nature Index Publishing policies Nature portfolio policies Open access Author & Researcher services Reprints & permissions Research data Language editing Scientific editing Nature Masterclasses Live Expert Trainer-led workshops Research Solutions Libraries & institutions Librarian service & tools Librarian portal Open research Recommend to library Advertising & partnerships Advertising Partnerships & Services Media kits Branded content Career development Nature Careers Nature Conferences Nature events Regional websites Nature Africa Nature China Nature India Nature Italy Nature Japan Nature Korea Nature Middle East Privacy Policy Use of cookies Your privacy choices/Manage cookies Legal notice Accessibility statement Terms & Conditions Your US state privacy rights © 2023 Springer Nature Limited Close Sign up for the Nature Briefing newsletter — what matters in science, free to your inbox daily.
Close Get the most important science stories of the day, free in your inbox.
