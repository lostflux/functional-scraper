old id = 2131
Entangling logical qubits with lattice surgery | Nature
2021
https://doi.org/10.1038%2Fs41586-020-03079-6

Thank you for visiting nature.com. You are using a browser version with limited support for CSS. To obtain the best experience, we recommend you use a more up to date browser (or turn off compatibility mode in Internet Explorer). In the meantime, to ensure continued support, we are displaying the site without styles and JavaScript.
AdvertisementEntangling logical qubits with lattice surgeryNaturevolume589,pages220–224 (2021)Cite this article6412Accesses25Citations158AltmetricMetricsdetailsSubjectsAbstractThe development of quantum computing architectures from early designs and current noisy devices to fully fledged quantum computers hinges on achieving fault tolerance using quantum error correction1,2,3,4. However, these correction capabilities come with an overhead for performing the necessary fault-tolerant logical operations on logical qubits (qubits that are encoded in ensembles of physical qubits and protected by error-correction codes)5,6,7,8. One of the most resource-efficient ways to implement logical operations is lattice surgery9,10,11, where groups of physical qubits, arranged on lattices, can be merged and split to realize entangling gates and teleport logical information. Here we report the experimental realization of lattice surgery between two qubits protected via a topological error-correction code in a ten-qubit ion-trap quantum information processor. In this system, we can carry out the necessary quantum non-demolition measurements through a series of local and entangling gates, as well as measurements on auxiliary qubits. In particular, we demonstrate entanglement between two logical qubits and we implement logical state teleportation between them. The demonstration of these operations—fundamental building blocks for quantum computation—through lattice surgery represents a step towards the efficient realization of fault-tolerant quantum computation.
You have full access to this article via your institution.
MainThe basis of quantum error correction (QEC) is storing and manipulating quantum information using logical qubits. A number of experiments have demonstrated significant technological progress towards QEC12,13,14,15, including the creation of non-trivial QEC codes16,17, error detection18,19,20, correction of errors21,22,23,24and qubit loss25, and operations on one26,27,28,29,30,31and on two logical qubits in non-topological codes32,33.
The most promising road towards QEC is offered by topological codes, such as the surface code34,35, which require only short-range interactions in two-dimensional (2D) architectures28,36,37. Nevertheless, the implementation of encoded operations remains a major challenge. Performing arbitrary logical operations requires costly techniques such as transversal gates5, teleported gates6, magic state distillation8and complex optimization38,39. Recent theoretical advances9,10in lattice surgery (LS)11include methods to reduce this complexity40while maintaining 2D layouts. In LS, the QEC code itself is altered by merging and splitting initially separate encodings, rather than by operating on all physical qubits. Such modifications can be used to manipulate logical qubits efficiently, or to adapt the robustness to different noise processes41. LS further enables entanglement generation between logical qubits and can be complemented with measurement-based protocols42,43for logical state teleportation and manipulation9. Here we report the experimental implementation of LS using 10 trapped ions to entangle two logical qubits encoded in two four-qubit surface codes35.
Surface codeOne of the most prominent examples of a QEC code is the surface code34,35, which has error thresholds of up to441%. The surface code has a simple description within the stabilizer formalism5, as we discuss in the following. Note that we work with qubits, that is, two-level quantum systems whose state space is defined by Pauli operatorsσx,σy,σzand the 2 × 2 identity matrix, which form a basis of the vector space of 2 × 2 Hermitian matrices. Here, we label Pauli matrices byX,Y,Zand associate a single physical qubit with them. More generally, we can identify a single logical qubit within a composite system of many physical qubits by defining tensor products of Pauli operatorsXL,YL,ZL, which obey the same commutation relation asX,Y,Z. This notion of logical operatorsℒ= {XL,YL,ZL} is used in QEC to define an encoding of a logical qubit in many physical qubits. We refer the reader to Methods for a more detailed introduction.
Here we consider the minimal instance of a surface code—a four-qubit code encoding a single logical qubit—as the central component of our experimental implementation. The code can be represented graphically, where the physical qubits are the vertices of a 2 × 2 bicolourable lattice, as shown in Fig.
1A, a(row ‘Schematic’, column ‘Encoded’) for two initially separate logical qubits labelled A and B. Depending on the colour, faces are associated with products of either Pauli-Xor Pauli-Zoperators of the adjacent physical qubits. In Fig.
1A, a(Schematic, Encoded) for example, the central, orange plaquettes can be associated with operatorsX1X2X3X4andX5X6X7X8. The resulting operators are called stabilizers and form a set (group) of operations—the stabilizer code\({{\mathcal{S}}}^{{\rm{A}}/{\rm{B}}}\)—under multiplication,Experimental results and schematics for LS betweenZ-type boundaries implementing a logical joint measurement\({M}_{{\rm{XX}}}^{+}\propto {\mathbb{I}}+{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)to generate a logical Bell state. We use the error detection capabilities of the code and post-select measurements with valid code stabilizers, which are presented in light coloured bars. Error bars indicate the standard deviation of the measured expectation values. We verify the code stabilizersSiby estimating the expectation value⟨Si⟩=p+−p−, wherep±is the probability of finding the encoded state in a ±1 eigenstate ofSi.
A, Encoded. Two surface codes (a) defined on 2 × 2 lattices with average code stabilizer values (b) of⟨|Si|⟩= 0.868(4) (error is calculated from individual stabilizer errors) whereX-stabilizers andZ-stabilizers in equation (1) are associated with orange and aquamarine faces, respectively. We observe (raw|post-selected) state fidelities (c)\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.8(4)|99.3(2){\rm{ \% }}\)and\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=93.4(5)|99.4(2){\rm{ \% }}\)for the encodings\(|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle \),\(|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \), respectively. Logical operators are products of Pauli operators connecting opposite boundaries (see equation (2)).
B, Merged. The stabilizers\({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\)along the boundaries (a) are measured (dark red) using auxiliary qubits A1, A2. This is done such that we obtain an eigenstate of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}={S}_{6}^{{\rm{M}}}{S}_{7}^{{\rm{M}}}\). Note that we use syndrome qubits (A1, A2) only for merging and splitting, not for error detection. The merged code (equation (3)) encodes a single logical qubit\(|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle \)corresponding to the logical operator\({Z}_{{\rm{L}}}^{{\rm{M}}}={Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\)in equation (4). We observe average stabilizer values (b) of⟨|Si|⟩= 0.669(8), and logical state fidelities (c)\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle )=86.4(1.0)|97.9(5){\rm{ \% }}\).
C, Split. In order to split the merged code (a) while preserving the eigenstate of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\), one boundary stabilizer\({S}_{2}^{{\rm{A}}}\)of the original code is measured (green) reusing auxiliary qubit A1and the associated syndrome is observed. In this way, we recover the original codes with average stabilizer values (b) of⟨|Si|⟩= 0.603(3) which are now in a logical Bell state\(|{\varphi }_{{\rm{L}}}^{+}\rangle \)with fidelity (c)\( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=58.0(1.6)|75.3(1.6){\rm{ \% }}\).
Note that we choose a negative sign for some stabilizers because this is advantageous for our implementation. The logical states\(|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle \)spanning the respective code spaces for A and B are defined as the simultaneous +1 eigenstates of all stabilizers, that is,\({S}_{i}^{{\rm{A}}/{\rm{B}}}|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle =|{\psi }_{{\rm{L}}}^{{\rm{A}}/{\rm{B}}}\rangle \),∀i∈{1, 2, 3}. Therefore, we find that each surface encodes a single logical qubit in two codewords,\(|{0}_{{\rm{L}}}\rangle =\frac{1}{\sqrt{2}}(|0101\rangle +|1010\rangle )\)and\(|{1}_{{\rm{L}}}\rangle =\frac{1}{\sqrt{2}}(|1001\rangle +|0110\rangle )\).
Logical operators map codewords to codewords. For instance, a logical bit-flip operator\({X}_{{\rm{L}}}^{{\rm{A}}}={X}_{1}{X}_{2}\)maps\(|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle \)to\(|{1}_{{\rm{L}}}^{{\rm{A}}}\rangle \). In the stabilizer formalism, logicalX- andZ-operators anti-commute with each other (that is, they obey the Pauli commutation relations) and commute with all stabilizers. For example,\({X}_{{\rm{L}}}^{{\rm{A}}}\)anti-commutes with the logical phase-flip operator\({Z}_{{\rm{L}}}^{{\rm{A}}}={Z}_{1}{Z}_{3}\)but commutes with\({S}_{1}^{{\rm{A}}}\). These operators are defined up to multiplication with other logical operators, stabilizers and the imaginary unit i. That is, the sets of logical operators are defined aswhere\(\langle {P}_{{\rm{L}}}\rangle /{\mathcal{S}}\)indicates that logical Pauli operatorsPLform equivalence classes defined up to multiplication with stabilizers (seeMethods). The logicalY-operator is determined asYL= iZLXLand we find\({Y}_{{\rm{L}}}^{{\rm{A}}}={Y}_{1}{X}_{2}{Z}_{3}\)and\({Y}_{{\rm{L}}}^{{\rm{B}}}={Y}_{5}{X}_{6}{Z}_{7}\).
In the stabilizer formalism, errors can be associated with finding an eigenvalue −1 when measuring a stabilizer operator. To see this, consider a bit-flip error represented byX1which can be detected by extracting the eigenvalue of\({S}_{1}^{{\rm{A}}}\),\({S}_{1}^{{\rm{A}}}{X}_{1}|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle =-\,{X}_{1}|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle \). This eigenvalue, or error syndrome, can be obtained by measuring an auxiliary qubit (or syndrome qubit) encoding the ±1 eigenvalue of the associated stabilizer. Scaling the surface code to detect and correct more errors is, in theory, as simple as scaling the lattice (seeMethods).
Lattice surgeryLS11is a fault-tolerant protocol for entangling QEC codes that is ideally suited to the geometry of 2D topological codes such as the surface code. This is because LS between topological codes requires only local, few-body interactions. LS11was introduced as a method to project two surface codes\({{\mathcal{S}}}^{{\rm{A}}}\)and\({{\mathcal{S}}}^{{\rm{B}}}\)with logical operators\({X}_{{\rm{L}}}^{{\rm{A}}}\),\({Z}_{{\rm{L}}}^{{\rm{A}}}\)and\({X}_{{\rm{L}}}^{{\rm{B}}}\),\({Z}_{{\rm{L}}}^{{\rm{B}}}\), respectively, onto joint eigenstates of either\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)or\({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\), referred to asZ-type andX-type LS, respectively. These projections are entangling operations and can be used to construct entangling gates. To clarify the notation, note that the lattice boundaries of surface codes can be distinguished by their associated stabilizers:Z-type stabilizers along the boundary define one type of boundary whileX-type stabilizers define another. Similarly, we label different types of LS by the boundary type they operate on. Here, we proceed by describingZ-type LS for the minimal 2 × 2 surface code discussed before, and refer to Methods for a more general introduction and details.
In order to project onto a logical eigenstate of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\), we perform a logical joint measurement\({M}_{{\rm{XX}}}^{\pm }=({\mathbb{I}}\pm {X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\), which can be used to entangle two logical qubits, and where\({\mathbb{I}}\)is the logical two-qubit identity matrix. To achieve this, LS proceeds in two steps: merging and splitting. This procedure is illustrated in Fig.
1B, a(Schematic, Merged) and Fig.
1C, a(Schematic, Split) for two 2 × 2 surface codes\({{\mathcal{S}}}^{{\rm{A}}}\)and\({{\mathcal{S}}}^{{\rm{B}}}\). We first merge the two separate codes\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\)into a new stabilizer code\({{\mathcal{S}}}^{{\rm{M}}}\)by measuring merging stabilizers\({S}_{6}^{{\rm{M}}}={X}_{3}{X}_{5}\)and\({S}_{7}^{{\rm{M}}}={X}_{4}{X}_{6}\)between the boundaries. These stabilizers commute with all stabilizers of the original codes except\({S}_{2}^{{\rm{A}}}\)and\({S}_{1}^{{\rm{B}}}\), and are chosen such that their joint measurement corresponds to the joint logical measurement\({M}_{{\rm{XX}}}^{\pm }\), that is,\({S}_{6}^{{\rm{M}}}{S}_{7}^{{\rm{M}}}={X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\). As a result, we obtain the new code by discarding all stabilizers that anti-commute with the merging stabilizers, depicted in Fig.
1B, a(Schematic, Merged),Note that this code already encodes the desired joint eigenstate since\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)is included as a stabilizer in the merged code\({{\mathcal{S}}}^{{\rm{M}}}\). In fact, the measurement outcomesm,m′∈{0, 1} of\({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\), respectively, are random such thatm1=m+m′ specifies the eigenvalue associated with\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)as\({(-1)}^{{{m}}_{1}}\). The merged code is an asymmetric 2 × 4 surface code encoding a single logical qubit, that is,and\({Y}_{{\rm{L}}}^{{\rm{M}}}={Y}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\).
With theZ-type merge we effectively merged the logicalZ-operators and performed the desired logical joint measurement\({M}_{{\rm{XX}}}^{\pm }\). Its expectation value ±1 is given by the product of the expectation values of merging stabilizers\({S}_{6}^{{\rm{M}}},{S}_{7}^{{\rm{M}}}\). Now, we must recover the two initial logical qubits while keeping the previously obtained expectation value of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\). To this end, we split the merged code by measuringZ-stabilizers\({S}_{2}^{{\rm{A}}}\)or\({S}_{1}^{{\rm{B}}}\)along the merged boundaries as depicted in Fig.
1C, a(Schematic, Split). These operators commute with all stabilizers in\({{\mathcal{S}}}^{{\rm{M}}}\)that define the separated logical qubits\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\). In particular, the measured stabilizers all commute with\({X}_{{\rm{L}}}^{{\rm{A}}}\),\({X}_{{\rm{L}}}^{{\rm{B}}}\), that is, the code remains in an eigenstate of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\). After splitting, measurement outcomesm″,m″′∈{0, 1} of stabilizers\({S}_{2}^{{\rm{A}}}\),\({S}_{1}^{{\rm{B}}}\), respectively, are random but can be tracked as errors. In conclusion, we have effectively performed a logical entangling operation,\({M}_{{\rm{XX}}}^{\pm }\), which can be used to entangle logical qubits and teleport information. Note that the scheme presented here differs from the original proposal11in that it removes the necessity of additional data qubits along the boundary4,9,40. Although this change generally does not affect fault tolerance and code distance9, it might alter the QEC capabilities of the underlying code by effectively changing the lattice on which the surface code is defined.
LS can further be used to realize a measurement-based scheme for logical state teleportation9. In Fig.
2, we illustrate this scheme for a logical\({M}_{{\rm{XX}}}^{\pm }\)measurement on two 5 × 5 surface codes. We use 5 × 5 surface codes in this theoretical example to exemplify how LS scales with increasing system size. The merging and splitting operations used to experimentally teleport quantum information between two 2 × 2 surface codes are illustrated in Fig.
1. Note that a similar scheme can be used to teleport information through a logical\({M}_{{\rm{ZZ}}}^{\pm }\)measurement (seeMethods).
We illustrate the theoretical state teleportation protocol between two 5 × 5 surface codes (a) to exemplify the general concept of lattice surgery for larger system sizes. The merging and splitting operations for state teleportation between two 2 × 2 surface codes, as experimentally implemented in this work, is depicted in Fig.
1.
b, Measurement-based scheme to teleport information of an arbitrary logical state |ψL⟩=α|0L⟩+β|1L⟩between two logical qubits using only single-qubit and two-qubit measurements. We start with a logical state\(|{\psi }_{{\rm{L}}}^{{\rm{A}}}\rangle \)encoded in a 5 × 5 surface code and an additional logical qubit in the state\(|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \).
c, We perform LS, that is, merging and splitting, to implement a joint measurement\({M}_{{\rm{XX}}}^{{{m}}_{1}}\), wherem1= 0, 1 labels measurement outcomes. The resulting state is entangled.
d, Measuring the initial code in the logicalZ-basis (that is, measuring all physical qubits in theZ-basis) with measurement outcomem2= 0, 1 teleports the logical information to the logical qubit B. Depending on the measurement outcomesm1,m2= 0, 1, logical Pauli corrections need to be considered.
ResultsWe demonstrate LS in an ion-trap quantum computer, based on atomic40Ca+ions in a linear Paul trap45. Each qubit is encoded in the |0⟩= |4S1/2(mj= −1/2)⟩and |1⟩= |3D5/2(mj= −1/2)⟩state of a single ion. Each experiment consists of (i) laser cooling and state preparation, (ii) coherent manipulation of the qubit states, and (iii) readout. (i) For cooling close to the motional ground state, we employ a three-stage process comprising Doppler cooling, polarization gradient cooling46and resolved sideband cooling followed by optical pumping into |0⟩. (ii) The qubits are manipulated with a laser at 729 nm. The available gate set includes single-qubitZ-rotations, multi-qubitX- andY-rotations and a multi-qubit entangling Mølmer–Sørensen (MS) gate. (iii) Qubit states are read out via electron-shelving. We utilize spectroscopic decoupling to perform operations selectively on a subset of ions by coherently shelving populations from |0⟩= |4S1/2(mj= −1/2)⟩to |3D5/2(mj= −3/2)⟩and from |1⟩= |3D5/2(mj= −1/2)⟩to |3D5/2(mj= +1/2)⟩. For more details we refer toSupplementary Information.
In Fig.
1, we demonstrate LS to entangle logical qubits along theZ-type boundary. Complementary results forX-type lattice surgery are provided in Methods. We start by encoding the separated logical qubits, each defined by three stabilizers (see equation (1)) and two logical operators (see equation (2)) in Fig.
1A(Encoded). As a first example, we choose to encode the logical qubits in the state\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \). We can create encoded states with average stabilizer expectation values of⟨|Si|⟩= 0.868(4), see Fig.
1A, b(Code stabilizers, Encoded). We make use of the obtained stabilizer information and post-select our data on states with valid code stabilizers (seeSupplementary Information), which amounts to discarding those measurements where an error was detected by the code. For the encoded states we infer fidelities of\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.8(4)|99.3(2){\rm{ \% }}\)and\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=93.4(5)|99.4(2){\rm{ \% }}\), where the first value describes the raw fidelity and the second represents the observed fidelity after post-selection; we use this format throughout this work to present fidelities of both uncorrected and post-selected data. Note that this post-selection introduces a finite survival probability (seeSupplementary Information).
Performing LS requires quantum-non-demolition (QND) measurements of stabilizers implemented by series of local and entangling gates. Considering two merging stabilizers mapped onto auxiliary qubits A1and A2, respectively, we have the possibility of detecting one of four possible outcomes (m,m′) = (0, 0), (0, 1), (1, 0), (1, 1). InSupplementary Information, we present data for all possible outcomes for the chosen input state. For experimental simplicity, the following results are for the case (m,m′) = (0, 0). The merged surface code, as defined in equation (3), is illustrated in Fig.
1B, b(Code stabilizers, Merged). The data confirm the merged stabilizers with an average stabilizer expectation value of⟨|Si|⟩= 0.669(8). Starting from the state\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \), the merged logical state is a +1 eigenstate of the logical\({Z}_{{\rm{L}}}^{{\rm{M}}}={Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\)operator, as can be seen in Fig.
1B, c(Logical operators, Merged). The data reveal a state fidelity of\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{M}}}\rangle )=86.4(1.0)|97.9(5){\rm{ \% }}\)after merging.
Now, we split the merged logical qubit along the same boundary by mapping\({S}_{2}^{{\rm{A}}}\)onto auxiliary qubit A1for the casem″ = 0. Thereby, we restore the initial code space with an average stabilizer expectation value of⟨|Si|⟩= 0.603(3), shown in Fig.
1C, b(Code stabilizers, Split). The resulting projective measurement\(({\mathbb{I}}+{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\)maps the initial product state\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \)onto a maximally entangled, logical Bell state\(|{\varphi }_{{\rm{L}}}^{+}\rangle =\frac{1}{\sqrt{2}}(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle +|{1}_{{\rm{L}}}^{{\rm{A}}}{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )\). In order to deduce the fidelity of the generated state with respect to the logical Bell state, we measure the common logical stabilizers\(\langle {Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}},{X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}},-\,{Y}_{{\rm{L}}}^{{\rm{A}}}{Y}_{{\rm{L}}}^{{\rm{B}}}\rangle \), obtaining the fidelity47In Fig.
1C(Split), we present the results for the Bell state generation. From the common stabilizer measurements, we infer a logical Bell state fidelity of\( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=58.0(1.6)|75.3(1.6){\rm{ \% }}\), where the raw fidelity exceeds the separability limit of 50% by 5 standard deviations. Imperfect physical gate implementations can be characterized48and match our expectations, as discussed inSupplementary Information. InSupplementary Information, we also demonstrate LS for various input states in order to generate different maximally entangled Bell states.
LS enables the teleporting of quantum states from one logical qubit to another (see Fig.
2), which we demonstrate for the input states\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \),\(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \)and\(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \). After performingZ-type LS (that is, encoding, merging, splitting), we measure logical qubit A in theZ-basis and apply a logical XLgate on qubit B if qubit A was found in\(|{1}_{{\rm{L}}}^{{\rm{A}}}\rangle \)(see Fig.
3). Following the teleportation protocol, we measure logical state fidelities for qubit B of\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=87(2)|97(1){\rm{ \% }}\),\( {\mathcal F} (|{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )=81(2)|93(2){\rm{ \% }}\)and\( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{B}}}\rangle )=71(1)|85(2){\rm{ \% }}\), given the input states\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \),\(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \)and\(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \), respectively.
a, Measurement-based scheme to teleport information of an arbitrary logical state |ψL⟩=α|0L⟩+β|1L⟩between two logical qubits (same as Fig.
2b). We prepare the logical qubits A, B in the states\(|{0}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \),\(|{1}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \)and\(|{+}_{{\rm{L}}}^{{\rm{A}}}{0}_{{\rm{L}}}^{{\rm{B}}}\rangle \)(b–d, respectively), and use LS to teleport the state from logical qubit A to logical qubit B as illustrated in Fig.
2. We measure fidelities of the teleported quantum states of\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=87(2)|97(1){\rm{ \% }}\)\( {\mathcal F} (|{1}_{{\rm{L}}}^{{\rm{B}}}\rangle )=81(2)|93(2){\rm{ \% }}\)and\( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{B}}}\rangle )=71(1)|85(2){\rm{ \% }}\)(e–g, respectively).
ConclusionWe have demonstrated entanglement generation and teleportation via LS between two logical qubits, each encoded in a four-qubit surface code, on a 10-qubit ion-trap quantum information processor. We have implemented both theZ- andX-type variants of LS9,35, a technique that is considered10,40to be key for operating future fault-tolerant quantum computers. For current NISQ (noisy intermediate-scale quantum)-era devices, certification of logical entanglement49generated via LS can provide the means of benchmarking. Besides increasing the numbers of physical and logical qubits, future challenges lie in the implementation of LS between arbitrary topological codes9to exploit different features, such as transversal gate implementation or high noise tolerance of the respective codes. In this way, LS can function as a fault-tolerant interface between quantum memories and quantum processors.
MethodsStabilizer quantum error correctionQuantum error correction (QEC) deals with the encoding and protection of quantum information stored in quantum systems. The simplest such systems are qubits, two-level (for example, spin-\(\frac{1}{2}\)) systems, whose degrees of freedom can be represented by the Pauli matricesPauli matrices, in conjunction with the identity\({\mathbb{I}}\), form a basis of the vector space of 2 × 2 Hermitian matrices, and so an arbitrary single-qubit density matrixρcan be parameterized as\(\rho =\frac{1}{2}\,({\mathbb{I}}+{\bf{a}}\cdot {\boldsymbol{\sigma }})\)where\({\bf{a}}\in {{\mathbb{R}}}^{3}\)is the so-called Bloch vector and\({\boldsymbol{\sigma }}={({\sigma }_{x},{\sigma }_{y},{\sigma }_{z})}^{{\rm{T}}}\). Qubits can therefore be described by Pauli observables. For example, instead of writing |0⟩⟨0|, we may write (\({\mathbb{I}}\)+Z)/2 where we useX,Y,Zas shorthand for Pauli matricesσx,σy,σzand |0⟩, |1⟩are the two eigenstates ofZwith eigenvalues ±1, respectively.
Interestingly, there are various ways of encoding a logical qubit in composite systems. Specifically, we may encode a qubit in either single- or multi-qubit observables. To see this, consider a pure two-qubit systemℂ2⊗ℂ2= span({|00⟩, |01⟩, |10⟩, |11⟩}). Let us now fix the second qubit to the +1 eigenstate ofZ2(that is, |0⟩2). Since this is a composite system, the eigenvalue is degenerate and we can define a single qubit by span({|0⟩1, |1⟩1}) where subscripts label qubits. However, we may also fix the composite system to the +1 eigenstate ofZ1Z2. We then can still define a qubit by span({|00⟩, |11⟩}). This qubit is associated with a new set of logical Pauli observables {XL,YL,ZL} = {X1X2,Y1X2,Z1}, which obey the same commutation relation asX1,Y1,Z1. This notion of encoding qubits in composite systems is used in QEC to protect quantum information.
In QEC our aim is to encode a few logical qubits into many physical qubits such that redundancies can be exploited to detect and correct errors. That is, we replace single-qubit basis states |0⟩, |1⟩by encoded, logical states |0L⟩, |1L⟩that are made up by many physical qubits. Consider for instance the encoding (or codewords) |0L⟩= |000⟩and |1L⟩= |111⟩where we redundantly encoded a logical qubit into three physical (or data) qubits. This code can correct for a single-qubitX-error. To see this, consider that we observe a state |100⟩. This state is not within the code subspace {|0L⟩, |1L⟩} and we have to conclude that either a single-qubit errorX1|0L⟩or a two-qubit errorX2X3|1L⟩occurred. Under the assumption that a single-qubit error is more likely to happen than two errors on two qubits, we exclude the latter possibility by a majority vote. We can always apply this reasoning to any single-qubit error. By contrast, whenever two-qubit errors occur, our correction would fail and we would effectively introduce a logical error that maps one codeword to another, for example,\(|{0}_{{\rm{L}}}\rangle \mapsto |{1}_{{\rm{L}}}\rangle \). When using the Hamming distance to measure the distance between states (which is equivalent to counting the number of single-qubit Pauli operators mapping one to the other), the correction procedure as described above maps an erroneous state to the nearest codeword.
In practice, we will not be able to observe the computational state until the end of a computation. However, we need to be able to perform QEC as described above throughout the computation. Therefore, it is important to note that we can actively observe single-qubit errors in the above code without disturbing the encoded information. This is done by considering so-called code stabilizers. These are mutually commuting operatorsSiin the three-qubit Pauli group\({{\mathcal{P}}}_{3}\)that map the code subspace to itself while acting as identity on the encoded information, that is,Si|0L⟩= |0L⟩,Si|1L⟩= |1L⟩and [Si,Sj] = 0. Since our code consists of three physical qubits while encoding a single logical qubit, we can expect to find two independent, commuting Pauli operators with this property. Indeed, we findS1=Z1Z2andS2=Z2Z3which can be used to generate a group\({\mathcal{S}}\)under multiplication, that is,\({\mathcal{S}}=\langle {S}_{1},{S}_{2}\rangle =\{{\mathbb{I}},{S}_{1},{S}_{2},{S}_{1}{S}_{2}\}\). This group is called the stabilizer group and contains all stabilizers for this codespace. Since the code subspace is an eigenspace of these operators, we can simultaneously measure all stabilizers without disturbing the logical information. Without errors, measuring stabilizers will always result in the same outcome, namely +1. However, were an errorX1to occur, the measurement outcome of stabilizerS1, its so-called syndromes1, would change sign since errors anti-commute with stabilizers, that is, {S1,X1} = 0. The only other combination ofX-errors that could possibly lead to the syndromess1= −1 ands2= +1 is a two-qubit errorX2X3. In practice, we collect these syndromes by measuring auxiliary qubits, so-called syndrome qubits, which encode the eigenvalues of associated stabilizers. That is, a projective stabilizer measurement can be performed by entangling data qubits with a syndrome qubit and measuring the latter. As a result, we end up with the same majority vote as before but without measuring the logical state of the encoded qubit. This is the convenience of the stabilizer formalism.
In this formalism, logical operations take a simple form as the normalizer\(N({\mathcal{S}})\subseteq {{\mathcal{P}}}_{3}\)of the stabilizer group which is the group of operators that leaves the stabilizer group invariant. We are only considering Pauli operators, and hence the normalizer is also the centralizer\(C({\mathcal{S}})\)of\({\mathcal{S}}\)which is the group of operators that commutes with all stabilizers. Since this definition includes stabilizers themselves, we define the group of logical operators as a quotient group\( {\mathcal L} =N({\mathcal{S}})/{\mathcal{S}}\)such that logical operators form equivalence classes under multiplication with stabilizers. In our case, the equivalence classes are\({[{\mathbb{I}}]}_{{\mathcal{S}}},{[{Z}_{1}]}_{{\mathcal{S}}},{[{X}_{1}{X}_{2}{X}_{3}]}_{{\mathcal{S}}}\), that is, one for each logical operation.
QEC is done to protect encoded information from non-trivial logical errors in\( {\mathcal L} \). Since we are only considering products of Pauli operators, elements of\( {\mathcal L} \)are also just products of Pauli operators. This allows us to infer the minimum number of single-qubit errors composing a logical error, that is, its distanced. To see this, consider the non-trivial operator\({Z}_{{\rm{L}}}\in {\mathcal L} \)and its weightw(ZL) which is the number of non-trivial terms in the product of Pauli operators. In our example,ZL=Z1, that is, its weight is 1 and a single-qubitZ-error can cause a logicalZ-error. In other words, the above code can tolerate noZ-errors and its distance is therefored= 1. However, with respect to logicalX-operators\({[{X}_{1}{X}_{2}{X}_{3}]}_{{\mathcal{S}}}\), the minimum weight of any logicalX-operator is 3 such that the code can correct 1 and detect 2X-errors. Since the correction procedure is based on majority voting, a code with distancedcan generally correct up to (d− 1)/2 errors and detect up tod− 1 errors. The distance of the code is also the minimal Hamming distance between codewords, that is, the minimum required number of single-qubit Pauli operators mapping any one codeword to another.
In summary, QEC in the stabilizer formalism is active in the sense that we are required to measure stabilizers and extract syndromes throughout a quantum computation. The syndromes can then be analysed to determine by a majority vote the errors that have occurred. Logical operators are operators that commute with all stabilizers but are not stabilizers themselves.
Surface codeHere we consider a general construction of surface codes in the stabilizer formalism. Considernqubits laid out on the verticesVof a bicoloured square lattice as displayed in Extended Data Fig.
1. Let us associate a stabilizer with each coloured plaquettep∈Pas follows,where\({\mathcal{N}}(p)\subseteq V\)is the set of vertices neighbouring a plaquettepandPis the set of faces.
X-stabilizersSXare placed on orange plaquettes whileZ-stabilizersSZare placed on aquamarine plaquettes. Since neighbouring plaquettes always share two vertices, stabilizers commute for allp∈P. For the lattice under consideration, there ares=n− 1 independent, commuting stabilizers. Therefore, the Hilbert space, which is the simultaneous +1 eigenspace of all stabilizers, hasn−s= 1 degree of freedom. This degree of freedom is a qubit since we can define logicalXLandZLPauli operators. In the case of the surface code, logical operators are products of Pauli operators connecting opposite boundaries of the lattice. To see this, consider a line drawn on the lattice connecting top and bottom boundaries, as indicated by dashed frames in Extended Data Fig.
1. PlacingX-operators on vertices enclosed by this frame, we obtain an operator commuting with all stabilizers but which is not a stabilizer itself. Therefore, this operator corresponds to a logical operatorXL. At the same time, we can analogously draw a line connecting left and right boundaries. PlacingZ-operators along this line, we obtain an operator commuting with all stabilizers but anti-commuting withXL. Therefore, this product of Pauli-Zoperators defines the logicalZ-operatorZL. Note that the shortest line connecting opposite boundaries crosses three vertices. Therefore, the code can correct up to one single-qubit error and has distanced= 3.
In order to perform QEC, we continuously measure the code stabilizers. Whenever a stabilizer measurement result, that is, its syndrome, changes sign from +1 to −1, we have detected an error. Assuming that less than (d− 1)/2 errors have occurred, we can associate with each syndrome a correction procedure which recovers the state of all +1 stabilizers from the erroneous state without causing a logical error.
Lattice surgeryHere, we consider lattice surgery (LS) in general as a method to project onto a joint eigenstate of logical Pauli operators. That is, LS maps two stabilizer QEC codes\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\)onto a joint eigenstate\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\)of two logical Pauli operators of the codes. This is achieved through a joint measurement\({M}_{P\mathop{P}\limits^{ \sim }}^{\pm }=({\mathbb{I}}\pm {P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}})/2\)which can be implemented fault-tolerantly. Note that an operation is called fault-tolerant if errors during the operation can only map to a constant number of physical qubits in the encoding independent of the code size. In Extended Data Fig.
2, we illustrate how joint Pauli measurements as described above can be used to implement logical CNOT and HadamardHgates as well as code teleportation through a measurement-based scheme.
LS itself proceeds in two steps: merging and splitting. In order to initialize a measurement\({M}_{P\mathop{P}\limits^{ \sim }}^{\pm }\), we first merge the two separated codes\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\)into a new stabilizer code\({{\mathcal{S}}}^{M}\)by projecting onto a joint eigenstate\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\). In order for this to be fault-tolerant, we measure a number of so-called merging stabilizers\({\{{S}_{i}^{M}\}}_{i}\)across the boundary such that\({\prod }_{i}{S}_{i}^{M}={P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\). This is displayed for the surface code in Extended Data Fig.
3where we consider\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\)to be 2 × 2 surface codes and\({P}_{{\rm{L}}}={\mathop{P}\limits^{ \sim }}_{{\rm{L}}}={X}_{{\rm{L}}},{Z}_{L}\), respectively. Then, the merged code is just a new surface code on an asymmetric lattice and the merging stabilizers are just surface code stabilizers at the interface between the two codes. Stabilizers at the boundary that do not commute with the merging stabilizers are discarded from the stabilizer group and only the product of boundary operators remain since they commute. Notably, the merged code encodes only a single logical qubit and\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\)is contained as a stabilizer. That is, this procedure projects onto an eigenstate of\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\). Its eigenvalue ±1 is determined by the measurement outcome of the product of merging stabilizers. In order to correct for measurement errors, we need to measure\({\{{S}_{i}^{M}\}}_{i}\)dtimes. These errors correspond to failed measurements that yield a syndromesalthough its expectation value is −s. Such measurement errors can be identified by comparing measurement results at different times.
Now, we want to recover the two initial logical qubits while remaining in an eigenstate of\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\). To this end, we split the merged code by measuring stabilizers of the separated codes\({{\mathcal{S}}}^{{\rm{A}}},{{\mathcal{S}}}^{{\rm{B}}}\)along the aligned boundaries as illustrated in Extended Data Fig.
3Crightmost column (Split). Since these stabilizers anti-commute with merging stabilizers, the set\({\{{S}_{i}^{M}\}}_{i}\)is discarded from the stabilizer groups and we recover the original two codes. However, since all stabilizers always commute with the logical operators, the resulting state remains an eigenstate of\({P}_{{\rm{L}}}^{{\rm{A}}}\otimes \mathop{P}\limits^{ \sim }{}_{{\rm{L}}}^{{\rm{B}}}\). At the end, QEC is required to ensure full fault-tolerance. Surface code LS usually distinguishesZ-type andX-type LS by association with the respective boundaries along which LS is performed. Note thatZ-type andX-type LS therefore refer to a projection onto an\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)or\({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\)eigenstate, respectively. Let us further point out that one may encounter a different terminology in terms of rough and smooth LS in the literature3,11. That notation is due to a different surface code representation and may be associated with what we callZ- andX-type LS, respectively. Generally however, we do not restrict toZ-type andX-type LS alone since a projection onto\({Z}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)can be used to generate a logical Hadamard as shown in Extended Data Fig.
2.
Results ofX-type LSX-type LS differs fromZ-type LS as described in the main text only in so far that both codes are considered to be rotated by 90° before LS. Equivalently, one can understandX-type LS as merging and splitting along the upper/lower instead of the left/right boundaries, as illustrated in Extended Data Fig.
3b(bottom row;X-type). In the case of two 2 × 2 surface codes, measuring the merging stabilizer\(\bar{S}{}_{7}^{{\rm{M}}}={Z}_{2}{Z}_{4}{Z}_{5}{Z}_{7}\), we obtain a 4 × 2 asymmetric surface codewhich can be split by discarding the merging stabilizer. It is worth noting that the merging operation already concludes the LS since the merging stabilizer is in fact\({Z}_{{\rm{L}}}^{A}\otimes {Z}_{{\rm{L}}}^{B}\). This is an artefact of reducing the general LS procedure as exemplified for a larger surface code in Fig.
2to distance-two surface codes.
We present the results for theX-type LS in Extended Data Fig.
4and report a Bell state fidelity of\( {\mathcal F} (|{\varphi }_{{\rm{L}}}^{+}\rangle )=63.9(2.8)|78.0(2.7){\rm{ \% }}\). Further measurement results for various input states can be found inSupplementary Information.
Data availabilityThe data that support the findings of this study are available athttps://doi.org/10.5281/zenodo.4081412.
Code availabilityAll codes used for data analysis are available from the corresponding authors upon reasonable request.
ReferencesPreskill, J. inIntroduction to Quantum Computation(eds Lo, H.-K., Popescu, S. & Spiller, T. P.) Ch. 8, 213–269 (World Scientific, 1997).
Devitt, S. J., Munro, W. J. & Nemoto, K. Quantum error correction for beginners.
Rep. Prog. Phys.
76, 076001 (2013).
ADSGoogle ScholarTerhal, B. M. Quantum error correction for quantum memories.
Rev. Mod. Phys.
87, 307–346 (2015).
ADSMathSciNetGoogle ScholarCampbell, E. T., Terhal, B. M. & Vuillot, C. Roads towards fault-tolerant universal quantum computation.
Nature549, 172–179 (2017); correction559, E6 (2018).
ADSCASGoogle ScholarGottesmann, D.
Stabilizer Codes and Quantum Error Correction. Ph.D. thesis, Caltech (1997).
Gottesman, D. & Chuang, I. L. Demonstrating the viability of universal quantum computation using teleportation and single-qubit operations.
Nature402, 390–393 (1999).
ADSCASGoogle ScholarEisert, J., Jacobs, K., Papadopoulos, P. & Plenio, M. B. Optimal local implementation of nonlocal quantum gates.
Phys. Rev. A62, 052317 (2000).
ADSGoogle ScholarBravyi, S. & Kitaev, A. Universal quantum computation with ideal Clifford gates and noisy ancillas.
Phys. Rev. A71, 022316 (2005).
ADSMathSciNetMATHGoogle ScholarPoulsen Nautrup, H., Friis, N. & Briegel, H. J. Fault-tolerant interface between quantum memories and quantum processors.
Nat. Commun.
8, 1321 (2017).
ADSPubMedPubMed CentralGoogle ScholarGutiérrez, M., Müller, M. & Bermúdez, A. Transversality and lattice surgery: exploring realistic routes toward coupled logical qubits with trapped-ion quantum processors.
Phys. Rev. A99, 022330 (2019).
ADSGoogle ScholarHorsman, C., Fowler, A. G., Devitt, S. & Van Meter, R. Surface code quantum computing by lattice surgery.
New J. Phys.
14, 123011 (2012).
ADSMathSciNetMATHGoogle ScholarChiaverini, J. et al. Realization of quantum error correction.
Nature432, 602–605 (2004).
ADSCASGoogle ScholarBoulant, N., Viola, L., Fortunato, E. M. & Cory, D. G. Experimental implementation of a concatenated quantum error-correcting code.
Phys. Rev. Lett.
94, 130501 (2005).
ADSPubMedPubMed CentralGoogle ScholarZhang, J., Gangloff, D., Moussa, O. & Laamme, R. Experimental quantum error correction with high fidelity.
Phys. Rev. A84, 034303 (2011).
ADSGoogle ScholarWootton, J. R. & Loss, D. Repetition code of 15 qubits.
Phys. Rev. A97, 052313 (2018).
ADSCASGoogle ScholarBell, B. A. et al. Experimental demonstration of a graph state quantum error-correction code.
Nat. Commun.
5, 3658 (2014).
ADSCASGoogle ScholarTakita, M., Cross, A. W., Córcoles, A. D., Chow, J. M. & Gambetta, J. M. Experimental demonstration of fault-tolerant state preparation with superconducting qubits.
Phys. Rev. Lett.
119, 180501 (2017).
ADSGoogle ScholarKelly, J. et al. State preservation by repetitive error detection in a superconducting quantum circuit.
Nature519, 66–69 (2015).
ADSCASGoogle ScholarLinke, N. M. et al. Fault-tolerant quantum error detection.
Sci. Adv.
3, e1701074 (2017).
ADSPubMedPubMed CentralGoogle ScholarAndersen, C. K. et al. Repeated quantum error detection in a surface code.
Nat. Phys.
16, 875–880 (2020).
CASGoogle ScholarAoki, T. et al. Quantum error correction beyond qubits.
Nat. Phys.
5, 541–546 (2009).
CASGoogle ScholarReed, M. D. et al. Realization of three-qubit quantum error correction with superconducting circuits.
Nature482, 382–385 (2012).
ADSCASGoogle ScholarWaldherr, G. et al. Quantum error correction in a solid-state hybrid spin register.
Nature506, 204–207 (2014).
ADSCASGoogle ScholarOfek, N. et al. Extending the lifetime of a quantum bit with error correction in superconducting circuits.
Nature536, 441–445 (2016).
ADSCASGoogle ScholarStricker, R. et al. Experimental deterministic correction of qubit loss.
Nature585, 207–210 (2020).
Google ScholarZhang, J., Laflamme, R. & Suter, D. Experimental implementation of encoded logical qubit operations in a perfect quantum error correcting code.
Phys. Rev. Lett.
109, 100503 (2012).
ADSGoogle ScholarNigg, D. et al. Quantum computations on a topologically encoded qubit.
Science345, 302–305 (2014).
ADSMathSciNetCASMATHGoogle ScholarBarends, R. et al. Superconducting quantum circuits at the surface code threshold for fault tolerance.
Nature508, 500–503 (2014).
ADSCASGoogle ScholarHeeres, R. W. et al. Implementing a universal gate set on a logical qubit encoded in an oscillator.
Nat. Commun.
8, 94 (2017).
ADSPubMedPubMed CentralGoogle ScholarGong, M. et al. Experimental verification of five-qubit quantum error correction with superconducting qubits. Preprint athttp://arXiv.org/abs/1907.04507(2019).
Hu, L. et al. Quantum error correction and universal gate set operation on a binomial bosonic logical qubit.
Nat. Phys.
15, 503–508 (2019).
CASGoogle ScholarChou, K. S. et al. Deterministic teleportation of a quantum gate between two logical qubits.
Nature561, 368–373 (2018).
ADSCASGoogle ScholarHarper, R. & Flammia, S. T. Fault-tolerant logical gates in the IBM quantum experience.
Phys. Rev. Lett.
122, 080504 (2019).
ADSCASGoogle ScholarDennis, E., Kitaev, A., Landahl, A. & Preskill, J. Topological quantum memory.
J. Math. Phys.
43, 4452–4505 (2002).
ADSMathSciNetMATHGoogle ScholarFowler, A. G., Mariantoni, M., Martinis, J. M. & Cleland, A. N. Surface codes: towards practical large-scale quantum computation.
Phys. Rev. A86, 032324 (2012).
ADSGoogle ScholarLekitsch, B. et al. Blueprint for a microwave trapped ion quantum computer.
Sci. Adv.
3, e1601540 (2017).
ADSPubMedPubMed CentralGoogle ScholarJones, N. C. et al. Layered architecture for quantum computing.
Phys. Rev. X2, 031007 (2012).
Google ScholarHerr, D., Nori, F. & Devitt, S. J. Optimization of lattice surgery is NP-hard.
npj Quantum Inf.
3, 35 (2017).
ADSGoogle ScholarHäner, T., Steiger, D. S., Svore, K. & Troyer, M. A software methodology for compiling quantum programs.
Quantum Sci. Technol.
3, 020501 (2018).
ADSGoogle ScholarLitinski, D. A game of surface codes: large-scale quantum computing with lattice surgery.
Quantum3, 128 (2019).
Google ScholarNautrup, H. P., Delfosse, N., Dunjko, V., Briegel, H. J. & Friis, N. Optimizing quantum error correction codes with reinforcement learning.
Quantum3, 215 (2019).
Google ScholarRaussendorf, R. & Briegel, H. J. A one-way quantum computer.
Phys. Rev. Lett.
86, 5188–5191 (2001).
ADSCASGoogle ScholarLanyon, B. P. et al. Measurement-based quantum computation with trapped ions.
Phys. Rev. Lett.
111, 210501 (2013).
ADSCASGoogle ScholarWang, D. S., Fowler, A. G. & Hollenberg, L. C. L. Surface code quantum computing with error rates over 1%.
Phys. Rev. A83, 020302(R) (2011).
ADSGoogle ScholarSchindler, P. et al. A quantum information processor with trapped ions.
New J. Phys.
15, 123012 (2013).
ADSGoogle ScholarEjtemaee, S. & Haljan, P. C. 3D Sisyphus cooling of trapped ions.
Phys. Rev. Lett.
119, 043001 (2017).
ADSCASGoogle ScholarFriis, N. et al. Observation of entangled states of a fully controlled 20-qubit system.
Phys. Rev. X8, 021012 (2018).
CASGoogle ScholarErhard, A. et al. Characterizing large-scale quantum computers via cycle benchmarking.
Nat. Commun.
10, 5347 (2019).
ADSPubMedPubMed CentralGoogle ScholarFriis, N., Vitagliano, G., Malik, M. & Huber, M. Entanglement certification from theory to experiment.
Nat. Rev. Phys.
1, 72–87 (2019).
Google ScholarDownload referencesAcknowledgementsWe acknowledge support from the Austrian Science Fund (FWF) through SFB BeyondC (grant F71). H.P.N. and H.J.B. acknowledge support from FWF project DK-ALM (grant W1259-N27). H.J.B. was also supported by the Ministerium für Wissenschaft, Forschung, und Kunst Baden-Württemberg (AZ:33-7533.-30-10/41/1). N.F. acknowledges support from the FWF through project P 31339-N27. A.E., M.M., L.P., R.S., M.R., P.S., T.M. and R.B. acknowledge funding by the US Army Research Office (ARO) through grant no. W911NF-14-1-0103. We also acknowledge funding by the Austrian Research Promotion Agency (FFG) contract 872766, and by the EU H2020-FETFLAG-2018-03 under grant agreement no. 820495. M.S. and V.N. acknowledge funding by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), via US ARO grant no. W911NF-16-1-0070. This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement no. 801110 and the Austrian Federal Ministry of Education, Science and Research (BMBWF). We acknowledge support from the IQI GmbH. All statements of fact, opinions or conclusions contained herein are those of the authors and should not be construed as representing the official views or policies of the funding agencies.
Author informationThese authors contributed equally: Alexander Erhard, Hendrik Poulsen NautrupAffiliationsInstitute for Experimental Physics, University of Innsbruck, Innsbruck, AustriaAlexander Erhard, Michael Meth, Lukas Postler, Roman Stricker, Martin Ringbauer, Philipp Schindler, Rainer Blatt & Thomas MonzInstitute for Theoretical Physics, University of Innsbruck, Innsbruck, AustriaHendrik Poulsen Nautrup, Hans J. Briegel & Nicolai FriisInstitute for Quantum Electronics, ETH Zürich, Zurich, SwitzerlandMartin Stadler & Vlad NegnevitskyFachbereich Philosophie, Universität Konstanz, Konstanz, GermanyHans J. BriegelInstitute for Quantum Optics and Quantum Information, Austrian Academy of Sciences, Innsbruck, AustriaRainer BlattInstitute for Quantum Optics and Quantum Information – IQOQI Vienna, Austrian Academy of Sciences, Vienna, AustriaNicolai FriisAlpine Quantum Technologies GmbH, Innsbruck, AustriaThomas MonzYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarYou can also search for this author inPubMedGoogle ScholarContributionsA.E., H.P.N., P.S. and N.F. wrote the manuscript and A.E., H.P.N., M.M., L.P., R.S., M.R., P.S., H.J.B., R.B., N.F. and T.M. provided revisions. A.E., H.P.N., P.S. and N.F. developed the research based on discussions with H.J.B., R.B. and T.M. H.P.N. and N.F. developed the theory. A.E. and P.S. performed the experiments. A.E., M.M., L.P., R.S., M.S., V.N., M.R., P.S., R.B. and T.M. contributed to the experimental setup. A.E., H.P.N., M.M., L.P., R.S., M.R., P.S., H.J.B., R.B., N.F. and T.M. contributed to discussions of the results and the manuscript.
Corresponding authorsCorrespondence toNicolai FriisorThomas Monz.
Ethics declarationsCompeting interestsT.M. and R.B. are founding members of Alpine Quantum Technologies GmbH.
Additional informationPeer review informationNaturethanks Rodney Van Meter, Theodore Yoder and the other, anonymous, reviewer(s) for their contribution to the peer review of this work. Peer reviewer reports are available.
Publisher’s noteSpringer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.
Extended data figures and tablesExtended Data Fig. 1 Standard surface code of distance 3.
The standard surface code is defined on a square lattice with (data) qubits located on vertices. Stabilizers are associated with faces and boundaries. Aquamarine faces and boundaries indicateZ-type stabilizers, as in equation (6). Red faces and boundaries indicateX-type stabilizers, as in equation (5). The surface code with boundaries encodes a single logical qubit defined by its logical Pauli-Xand Pauli-Zoperators. These operators are defined on paths connecting opposite boundaries of the lattice and act as products ofX- andZ-operators, respectively, along the paths. Here, two representative logical operators are drawn as products of Pauli-operators within the dashed rectangles. Red indicates Pauli-Xoperators and green indicates Pauli-Zoperators. The two operators anti-commute at the crossing drawn in yellow.
Extended Data Fig. 2 Fault-tolerant logic gates with lattice surgery.
Lattice surgery (LS) enables measurement-based implementations of logic gates and logical state teleportation. LS operations are logical joint measurements of the form\({M}_{P\mathop{P}\limits^{ \sim }}=({\mathbb{I}}\pm P\mathop{P}\limits^{ \sim })/2\)where\(P,\mathop{P}\limits^{ \sim }\)are Pauli operators. Moreover, the protocols make use of single-qubit measurements of the formMP= (\({\mathbb{I}}\)±P)/2. Thick lines indicate logical qubits in the circuit model and double lines represent classical bits indicating measurement outcomesmi= 0, 1. Pauli corrections need to be applied which are conditioned on the measurement outcomes as\({P}_{{\rm{L}}}^{{m}_{i}}\). The symbol⊕represents an XOR-gate between classical bits.
a, Measurement-based implementation of a logical CNOT-gate between arbitrary control and target qubits requiring an auxiliary qubit in the |+L⟩state.
b, Measurement-based teleportation protocol for state teleportation between two logical qubits usingX-type LS.
c, Measurement-based implementation of a logical Hadamard gateHbased on the teleportation protocol.
Extended Data Fig. 3 Surface code lattice surgery in theory.
Surface code LS betweenZ-type andX-type boundaries implementing logical joint measurements\({M}_{{\rm{XX}}}^{\pm }=({\mathbb{I}}\pm {X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}})/2\)(a) and\({M}_{{\rm{ZZ}}}^{\pm }=({\mathbb{I}}\pm {Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}})/2\)(b), respectively.
A, Encoded. The two initial surface codes are defined on 2 × 2 lattices whereX-stabilizers are associated with orange faces andZ-stabilizers with aquamarine faces in accordance with equation (1). Logical operators are products of Pauli operators connecting opposite boundaries as in equation (2).
a,Z-type encoded. The two surface codes are arranged such that they are aligned along theirZ-type boundary.
b, X-type encoded. The surface codes are aligned along theirX-type boundary.
B, Merged. Treating the two codes as a single (asymmetric) surface code, (merging) stabilizers along the boundaries are measured. The merged code encodes a single logical qubit corresponding to the logical Pauli operators\({X}_{{\rm{L}}}^{{\rm{M}}},{Z}_{{\rm{L}}}^{{\rm{M}}}\).
a,Z-type merged. Merging stabilizers (indicated in red) are chosen such that their product is\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\).
b,X-type merged. Merging stabilizers (indicated in green) are chosen such that their product is\({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\).
C, Split. In order to split the merged code while preserving the eigenstate of the joint logical operator, the boundary stabilizers of the original code are measured. These operators anti-commute with the merging stabilizers and thus project onto the individual codes. Since the boundary operators commute with individual logical operators, the resulting state remains an eigenstate of the joint logical operator.
a,Z-type split. MeasuringZ-stabilizers along the boundary (indicated in green) preserves the eigenstate of\({X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)while projecting onto the individual codes.
b,X-type split. MeasuringX-stabilizers along the boundary (indicated in red) preserves the eigenstate of\({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\)while projecting onto the individual codes.
Extended Data Fig. 4 ExperimentalX-type surface code lattice surgery.
Bell state generation via lattice surgery along theX-type boundary between two surface code qubits through a logical joint measurement\({M}_{{\rm{ZZ}}}^{+}\propto {\mathbb{I}}+{Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\). Post-selected measurements are presented in light coloured bars.
A, Encoded. Two logical qubits (a) are encoded with average stabilizer values (b) of⟨|Si|⟩= 0.813(4). We observe raw and post-selected state fidelities (c) of\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{A}}}\rangle )=93.3(5)|98.7(2){\rm{ \% }}\)for logical qubit A and\( {\mathcal F} (|{0}_{{\rm{L}}}^{{\rm{B}}}\rangle )=92.4(5)|97.9(3){\rm{ \% }}\)for logical qubit B.
B, Merged. The two separated logical qubits are merged (a) into a single logical qubit by measuring the stabilizer\({S}_{7}^{{\rm{M}}}\)using auxiliary qubit A1as syndrome qubit. Thereby, the code space is extended in the vertical direction and the new logical operator\({X}_{{\rm{L}}}^{{\rm{M}}}={X}_{{\rm{L}}}^{{\rm{A}}}{X}_{{\rm{L}}}^{{\rm{B}}}\)is formed. As the data show, the stabilizer\({S}_{7}^{{\rm{M}}}\)is indeed created. The average stabilizer values (b) are⟨|Si|⟩= 0.719(5) and logical state fidelities (c) are\( {\mathcal F} (|{+}_{{\rm{L}}}^{{\rm{M}}}\rangle )=76.2(8)|93.1(6){\rm{ \% }}\).
C, Split. The single logical qubit is again split into two logical qubits (a) along the same boundary they have been initially merged through. We measure the stabilizer\(\bar{S}{}_{6}^{{\rm{M}}}\)by using auxiliary qubit A2as syndrome qubit to perform the splitting and obtain average stabilizer values (b) of⟨|Si|⟩= 0.763(5). The fidelity (c) of the generated state to the logical Bell state is\( {\mathcal F} (|{\psi }_{{\rm{L}}}^{+}\rangle )=63.9(2.8)|78.0(2.7){\rm{ \% }}\). Note that measuring the merging stabilizer\({S}_{7}^{{\rm{M}}}\)=\({Z}_{{\rm{L}}}^{{\rm{A}}}{Z}_{{\rm{L}}}^{{\rm{B}}}\)directly projects onto a joint eigenstate of the logicalZ-operators such that the splitting becomes redundant. Nevertheless, the general procedure as described in Methods requires the measurement ofX-stabilizers along the boundary which is why it is still included here.
Supplementary informationSupplementary InformationThis file contains additional details on the performed experiment.
Peer Review FileRights and permissionsReprints and PermissionsAbout this articleCite this articleErhard, A., Poulsen Nautrup, H., Meth, M.
et al.
Entangling logical qubits with lattice surgery.
Nature589,220–224 (2021). https://doi.org/10.1038/s41586-020-03079-6Download citationReceived:01 July 2020Accepted:20 October 2020Published:13 January 2021Issue Date:14 January 2021DOI:https://doi.org/10.1038/s41586-020-03079-6Share this articleAnyone you share the following link with will be able to read this content:Sorry, a shareable link is not currently available for this article.
Provided by the Springer Nature SharedIt content-sharing initiativeFurther readingVersatile neutral atoms take on quantum circuitsNature(2022)A quantum processor based on coherent transport of entangled atom arraysNature(2022)Logical-qubit operations in an error-detecting surface codeNature Physics(2022)CommentsBy submitting a comment you agree to abide by ourTermsandCommunity Guidelines. If you find something abusive or that does not comply with our terms or guidelines please flag it as inappropriate.
You have full access to this article via your institution.
AdvertisementExplore contentAbout the journalPublish with usSearchAdvanced searchQuick linksNature (Nature)ISSN1476-4687(online)ISSN0028-0836(print)nature.com sitemapDiscover contentPublishing policiesAuthor & Researcher servicesLibraries & institutionsAdvertising & partnershipsCareer developmentRegional websitesLegal & Privacy© 2022 Springer Nature LimitedSign up for theNature Briefingnewsletter — what matters in science, free to your inbox daily.
