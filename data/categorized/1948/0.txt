old id = 1224
Central processing unit - Wikipedia
1948
https://en.wikipedia.org/wiki/Central_processing_unit

Central processing unitAcentral processing unit(CPU), also called acentral processor,main processoror justprocessor, is theelectronic circuitrythat executesinstructionscomprising acomputer program. The CPU performs basicarithmetic, logic, controlling, andinput/output(I/O) operations specified by the instructions in the program. This contrasts with external components such asmain memoryand I/O circuitry,[1]and specialized processors such asgraphics processing units(GPUs).
The form,design, and implementation of CPUs have changed over time, but their fundamental operation remains almost unchanged. Principal components of a CPU include thearithmetic–logic unit(ALU) that performs arithmetic andlogic operations,processor registersthat supplyoperandsto the ALU and store the results of ALU operations, and acontrol unitthat orchestrates the fetching (from memory), decoding and execution of instructions by directing the coordinated operations of the ALU, registers and other components.
Most modern CPUs are implemented onintegrated circuit(IC)microprocessors, with one or more CPUs on a single IC chip. Microprocessor chips with multiple CPUs aremulti-core processors. The individual physical CPUs,processor cores, can also bemultithreadedto create additional virtual or logical CPUs.
[2]An IC that contains a CPU may also containmemory,peripheralinterfaces, and other components of a computer; such integrated devices are variously calledmicrocontrollersorsystems on a chip(SoC).
Array processors orvector processorshave multiple processors that operate in parallel, with no unit considered central.
Virtual CPUsare an abstraction of dynamical aggregated computational resources.
[3]ContentsHistory[edit]Early computers such as theENIAChad to be physically rewired to perform different tasks, which caused these machines to be called "fixed-program computers".
[4]The "central processing unit" term has been in use since as early as 1955.
[5][6]Since the term "CPU" is generally defined as a device forsoftware(computer program) execution, the earliest devices that could rightly be called CPUs came with the advent of thestored-program computer.
The idea of a stored-program computer had been already present in the design ofJ. Presper EckertandJohn William Mauchly'sENIAC, but was initially omitted so that it could be finished sooner.
[7]On June 30, 1945, before ENIAC was made, mathematicianJohn von Neumanndistributed the paper entitledFirst Draft of a Report on the EDVAC. It was the outline of a stored-program computer that would eventually be completed in August 1949.
[8]EDVACwas designed to perform a certain number of instructions (or operations) of various types. Significantly, the programs written for EDVAC were to be stored in high-speedcomputer memoryrather than specified by the physical wiring of the computer.
[9]This overcame a severe limitation of ENIAC, which was the considerable time and effort required to reconfigure the computer to perform a new task.
[10]With von Neumann's design, the program that EDVAC ran could be changed simply by changing the contents of the memory. EDVAC, however, was not the first stored-program computer; theManchester Baby, a small-scale experimental stored-program computer, ran its first program on 21 June 1948[11]and theManchester Mark 1ran its first program during the night of 16–17 June 1949.
[12]Early CPUs were custom designs used as part of a larger and sometimes distinctive computer.
[13]However, this method of designing custom CPUs for a particular application has largely given way to the development of multi-purpose processors produced in large quantities. This standardization began in the era of discretetransistormainframesandminicomputersand has rapidly accelerated with the popularization of theintegrated circuit(IC). The IC has allowed increasingly complex CPUs to be designed and manufactured to tolerances on the order ofnanometers.
[14]Both the miniaturization and standardization of CPUs have increased the presence of digital devices in modern life far beyond the limited application of dedicated computing machines. Modern microprocessors appear in electronic devices ranging from automobiles[15]to cellphones,[16]and sometimes even in toys.
[17][18]While von Neumann is most often credited with the design of the stored-program computer because of his design of EDVAC, and the design became known as thevon Neumann architecture, others before him, such asKonrad Zuse, had suggested and implemented similar ideas.
[19]The so-calledHarvard architectureof theHarvard Mark I, which was completed before EDVAC,[20][21]also used a stored-program design usingpunched paper taperather than electronic memory.
[22]The key difference between the von Neumann and Harvard architectures is that the latter separates the storage and treatment of CPU instructions and data, while the former uses the same memory space for both.
[23]Most modern CPUs are primarily von Neumann in design, but CPUs with the Harvard architecture are seen as well, especially in embedded applications; for instance, theAtmel AVRmicrocontrollers are Harvard architecture processors.
[24]Relaysandvacuum tubes(thermionic tubes) were commonly used as switching elements;[25][26]a useful computer requires thousands or tens of thousands of switching devices. The overall speed of a system is dependent on the speed of the switches.
Vacuum-tube computerssuch as EDVAC tended to average eight hours between failures, whereas relay computers like the (slower, but earlier)Harvard Mark Ifailed very rarely.
[6]In the end, tube-based CPUs became dominant because the significant speed advantages afforded generally outweighed the reliability problems. Most of these early synchronous CPUs ran at lowclock ratescompared to modern microelectronic designs. Clock signal frequencies ranging from 100kHzto 4 MHz were very common at this time, limited largely by the speed of the switching devices they were built with.
[27]Transistor CPUs[edit]The design complexity of CPUs increased as various technologies facilitated building smaller and more reliable electronic devices. The first such improvement came with the advent of thetransistor. Transistorized CPUs during the 1950s and 1960s no longer had to be built out of bulky, unreliable and fragile switching elements likevacuum tubesandrelays.
[28]With this improvement, more complex and reliable CPUs were built onto one or severalprinted circuit boardscontaining discrete (individual) components.
In 1964,IBMintroduced itsIBM System/360computer architecture that was used in a series of computers capable of running the same programs with different speed and performance.
[29]This was significant at a time when most electronic computers were incompatible with one another, even those made by the same manufacturer. To facilitate this improvement, IBM used the concept of amicroprogram(often called "microcode"), which still sees widespread usage in modern CPUs.
[30]The System/360 architecture was so popular that it dominated themainframe computermarket for decades and left a legacy that is still continued by similar modern computers like the IBMzSeries.
[31][32]In 1965,Digital Equipment Corporation(DEC) introduced another influential computer aimed at the scientific and research markets, thePDP-8.
[33]Transistor-based computers had several distinct advantages over their predecessors. Aside from facilitating increased reliability and lower power consumption, transistors also allowed CPUs to operate at much higher speeds because of the short switching time of a transistor in comparison to a tube or relay.
[34]The increased reliability and dramatically increased speed of the switching elements (which were almost exclusively transistors by this time); CPU clock rates in the tens of megahertz were easily obtained during this period.
[35]Additionally, while discrete transistor and IC CPUs were in heavy usage, new high-performance designs likesingle instruction, multiple data(SIMD)vector processorsbegan to appear.
[36]These early experimental designs later gave rise to the era of specializedsupercomputerslike those made byCray IncandFujitsu Ltd.
[36]Small-scale integration CPUs[edit]During this period, a method of manufacturing many interconnected transistors in a compact space was developed. Theintegrated circuit(IC) allowed a large number of transistors to be manufactured on a singlesemiconductor-baseddie, or "chip". At first, only very basic non-specialized digital circuits such asNOR gateswere miniaturized into ICs.
[37]CPUs based on these "building block" ICs are generally referred to as "small-scale integration" (SSI) devices. SSI ICs, such as the ones used in theApollo Guidance Computer, usually contained up to a few dozen transistors. To build an entire CPU out of SSI ICs required thousands of individual chips, but still consumed much less space and power than earlier discrete transistor designs.
[38]IBM'sSystem/370, follow-on to the System/360, used SSI ICs rather thanSolid Logic Technologydiscrete-transistor modules.
[39][40]DEC'sPDP-8/I and KI10PDP-10also switched from the individual transistors used by the PDP-8 and PDP-10 to SSI ICs,[41]and their extremely popularPDP-11line was originally built with SSI ICs but was eventually implemented with LSI components once these became practical.
Large-scale integration CPUs[edit]Lee Boysel published influential articles, including a 1967 "manifesto", which described how to build the equivalent of a 32-bit mainframe computer from a relatively small number oflarge-scale integrationcircuits (LSI).
[42][43]The only way to build LSI chips, which are chips with a hundred or more gates, was to build them using ametal–oxide–semiconductor(MOS)semiconductor manufacturing process(eitherPMOS logic,NMOS logic, orCMOSlogic). However, some companies continued to build processors out of bipolartransistor–transistor logic(TTL) chips because bipolar junction transistors were faster than MOS chips up until the 1970s (a few companies such asDatapointcontinued to build processors out of TTL chips until the early 1980s).
[43]In the 1960s, MOS ICs were slower and initially considered useful only in applications that required low power.
[44][45]Following the development ofsilicon-gateMOS technology byFederico Fagginat Fairchild Semiconductor in 1968, MOS ICs largely replaced bipolar TTL as the standard chip technology in the early 1970s.
[46]As themicroelectronictechnology advanced, an increasing number of transistors were placed on ICs, decreasing the number of individual ICs needed for a complete CPU. MSI and LSI ICs increased transistor counts to hundreds, and then thousands. By 1968, the number of ICs required to build a complete CPU had been reduced to 24 ICs of eight different types, with each IC containing roughly 1000 MOSFETs.
[47]In stark contrast with its SSI and MSI predecessors, the first LSI implementation of the PDP-11 contained a CPU composed of only four LSI integrated circuits.
[48]Microprocessors[edit]Since the introduction of the first commercially available microprocessor, theIntel 4004in 1971, and the first widely used microprocessor, theIntel 8080in 1974, this class of CPUs has almost completely overtaken all other central processing unit implementation methods. Mainframe and minicomputer manufacturers of the time launched proprietary IC development programs to upgrade their oldercomputer architectures, and eventually producedinstruction setcompatible microprocessors that were backward-compatible with their older hardware and software. Combined with the advent and eventual success of the ubiquitouspersonal computer, the termCPUis now applied almost exclusively[a]to microprocessors. Several CPUs (denotedcores) can be combined in a single processing chip.
[49]Previous generations of CPUs were implemented asdiscrete componentsand numerous smallintegrated circuits(ICs) on one or more circuit boards.
[50]Microprocessors, on the other hand, are CPUs manufactured on a very small number of ICs; usually just one.
[51]The overall smaller CPU size, as a result of being implemented on a single die, means faster switching time because of physical factors like decreased gateparasitic capacitance.
[52][53]This has allowed synchronous microprocessors to have clock rates ranging from tens of megahertz to several gigahertz. Additionally, the ability to construct exceedingly small transistors on an IC has increased the complexity and number of transistors in a single CPU many fold. This widely observed trend is described byMoore's law, which had proven to be a fairly accurate predictor of the growth of CPU (and other IC) complexity until 2016.
[54][55]While the complexity, size, construction and general form of CPUs have changed enormously since 1950,[56]the basic design and function has not changed much at all. Almost all common CPUs today can be very accurately described as von Neumann stored-program machines.
[57][b]As Moore's law no longer holds, concerns have arisen about the limits of integrated circuit transistor technology. Extreme miniaturization ofelectronic gatesis causing the effects of phenomena likeelectromigrationandsubthreshold leakageto become much more significant.
[59][60]These newer concerns are among the many factors causing researchers to investigate new methods of computing such as thequantum computer, as well as to expand the usage ofparallelismand other methods that extend the usefulness of the classical von Neumann model.
Operation[edit]The fundamental operation of most CPUs, regardless of the physical form they take, is to execute a sequence of storedinstructionsthat is called a program. The instructions to be executed are kept in some kind ofcomputer memory. Nearly all CPUs follow the fetch, decode and execute steps in their operation, which are collectively known as theinstruction cycle.
After the execution of an instruction, the entire process repeats, with the next instruction cycle normally fetching the next-in-sequence instruction because of the incremented value in theprogram counter. If a jump instruction was executed, the program counter will be modified to contain the address of the instruction that was jumped to and program execution continues normally. In more complex CPUs, multiple instructions can be fetched, decoded and executed simultaneously. This section describes what is generally referred to as the "classic RISC pipeline", which is quite common among the simple CPUs used in many electronic devices (often called microcontrollers). It largely ignores the important role of CPU cache, and therefore the access stage of the pipeline.
Some instructions manipulate the program counter rather than producing result data directly; such instructions are generally called "jumps" and facilitate program behavior likeloops, conditional program execution (through the use of a conditional jump), and existence offunctions.
[c]In some processors, some other instructions change the state of bits in a"flags" register. These flags can be used to influence how a program behaves, since they often indicate the outcome of various operations. For example, in such processors a "compare" instruction evaluates two values and sets or clears bits in the flags register to indicate which one is greater or whether they are equal; one of these flags could then be used by a later jump instruction to determine program flow.
Fetch[edit]The first step, fetch, involves retrieving aninstruction(which is represented by a number or sequence of numbers) from program memory. The instruction's location (address) in program memory is determined by theprogram counter(PC; called the "instruction pointer" inIntel x86 microprocessors), which stores a number that identifies the address of the next instruction to be fetched. After an instruction is fetched, the PC is incremented by the length of the instruction so that it will contain the address of the next instruction in the sequence.
[d]Often, the instruction to be fetched must be retrieved from relatively slow memory, causing the CPU to stall while waiting for the instruction to be returned. This issue is largely addressed in modern processors by caches and pipeline architectures (see below).
Decode[edit]The instruction that the CPU fetches from memory determines what the CPU will do. In the decode step, performed bybinary decodercircuitry known as theinstruction decoder, the instruction is converted into signals that control other parts of the CPU.
The way in which the instruction is interpreted is defined by the CPU's instruction set architecture (ISA).
[e]Often, one group of bits (that is, a "field") within the instruction, called the opcode, indicates which operation is to be performed, while the remaining fields usually provide supplemental information required for the operation, such as the operands. Those operands may be specified as a constant value (called an immediate value), or as the location of a value that may be aprocessor registeror a memory address, as determined by someaddressing mode.
In some CPU designs the instruction decoder is implemented as a hardwired, unchangeable binary decoder circuit. In others, amicroprogramis used to translate instructions into sets of CPU configuration signals that are applied sequentially over multiple clock pulses. In some cases the memory that stores the microprogram is rewritable, making it possible to change the way in which the CPU decodes instructions.
Execute[edit]After the fetch and decode steps, the execute step is performed. Depending on the CPU architecture, this may consist of a single action or a sequence of actions. During each action, control signals electrically enable or disable various parts of the CPU so they can perform all or part of the desired operation. The action is then completed, typically in response to a clock pulse. Very often the results are written to an internal CPU register for quick access by subsequent instructions. In other cases results may be written to slower, but less expensive and higher capacitymain memory.
For example, if an addition instruction is to be executed, registers containing operands (numbers to be summed) are activated, as are the parts of thearithmetic logic unit(ALU) that perform addition. When the clock pulse occurs, the operands flow from the source registers into the ALU, and the sum appears at its output. On subsequent clock pulses, other components are enabled (and disabled) to move the output (the sum of the operation) to storage (e.g., a register or memory). If the resulting sum is too large (i.e., it is larger than the ALU's output word size), an arithmetic overflow flag will be set, influencing the next operation.
Structure and implementation[edit]Hardwired into a CPU's circuitry is a set of basic operations it can perform, called aninstruction set. Such operations may involve, for example, adding or subtracting two numbers, comparing two numbers, or jumping to a different part of a program. Each instruction is represented by a unique combination ofbits, known as the machine languageopcode. While processing an instruction, the CPU decodes the opcode (via abinary decoder) into control signals, which orchestrate the behavior of the CPU. A complete machine language instruction consists of an opcode and, in many cases, additional bits that specify arguments for the operation (for example, the numbers to be summed in the case of an addition operation). Going up the complexity scale, a machine language program is a collection of machine language instructions that the CPU executes.
The actual mathematical operation for each instruction is performed by acombinational logiccircuit within the CPU's processor known as thearithmetic–logic unitor ALU. In general, a CPU executes an instruction by fetching it from memory, using its ALU to perform an operation, and then storing the result to memory. Beside the instructions for integer mathematics and logic operations, various other machine instructions exist, such as those for loading data from memory and storing it back, branching operations, and mathematical operations on floating-point numbers performed by the CPU'sfloating-point unit(FPU).
[61]Control unit[edit]Thecontrol unit(CU) is a component of the CPU that directs the operation of the processor. It tells the computer's memory, arithmetic and logic unit and input and output devices how to respond to the instructions that have been sent to the processor.
It directs the operation of the other units by providing timing and control signals. Most computer resources are managed by the CU. It directs the flow of data between the CPU and the other devices.
John von Neumannincluded the control unit as part of thevon Neumann architecture. In modern computer designs, the control unit is typically an internal part of the CPU with its overall role and operation unchanged since its introduction.
[62]Arithmetic logic unit[edit]The arithmetic logic unit (ALU) is a digital circuit within the processor that performs integer arithmetic andbitwise logicoperations. The inputs to the ALU are the data words to be operated on (calledoperands), status information from previous operations, and a code from the control unit indicating which operation to perform. Depending on the instruction being executed, the operands may come frominternal CPU registersor external memory, or they may be constants generated by the ALU itself.
When all input signals have settled and propagated through the ALU circuitry, the result of the performed operation appears at the ALU's outputs. The result consists of both a data word, which may be stored in a register or memory, and status information that is typically stored in a special, internal CPU register reserved for this purpose.
Address generation unit[edit]Address generation unit(AGU), sometimes also calledaddress computation unit(ACU),[63]is anexecution unitinside the CPU that calculatesaddressesused by the CPU to accessmain memory. By having address calculations handled by separate circuitry that operates in parallel with the rest of the CPU, the number ofCPU cyclesrequired for executing variousmachine instructionscan be reduced, bringing performance improvements.
While performing various operations, CPUs need to calculate memory addresses required for fetching data from the memory; for example, in-memory positions ofarray elementsmust be calculated before the CPU can fetch the data from actual memory locations. Those address-generation calculations involve differentinteger arithmetic operations, such as addition, subtraction,modulo operations, orbit shifts. Often, calculating a memory address involves more than one general-purpose machine instruction, which do not necessarilydecode and executequickly. By incorporating an AGU into a CPU design, together with introducing specialized instructions that use the AGU, various address-generation calculations can be offloaded from the rest of the CPU, and can often be executed quickly in a single CPU cycle.
Capabilities of an AGU depend on a particular CPU and itsarchitecture. Thus, some AGUs implement and expose more address-calculation operations, while some also include more advanced specialized instructions that can operate on multipleoperandsat a time. Furthermore, some CPU architectures include multiple AGUs so more than one address-calculation operation can be executed simultaneously, bringing further performance improvements by capitalizing on thesuperscalarnature of advanced CPU designs. For example,Intelincorporates multiple AGUs into itsSandy BridgeandHaswellmicroarchitectures, which increase bandwidth of the CPU memory subsystem by allowing multiple memory-access instructions to be executed in parallel.
Memory management unit (MMU)[edit]Many microprocessors (in smartphones and desktop, laptop, server computers) have a memory management unit, translating logical addresses into physical RAM addresses, providingmemory protectionandpagingabilities, useful forvirtual memory. Simpler processors, especiallymicrocontrollers, usually don't include an MMU.
Cache[edit]ACPU cache[64]is ahardware cacheused by the central processing unit (CPU) of acomputerto reduce the average cost (time or energy) to accessdatafrom themain memory. A cache is a smaller, faster memory, closer to aprocessor core, which stores copies of the data from frequently used mainmemory locations. Most CPUs have different independent caches, includinginstructionanddata caches, where the data cache is usually organized as a hierarchy of more cache levels (L1, L2, L3, L4, etc.).
All modern (fast) CPUs (with few specialized exceptions[65]) have multiple levels of CPU caches. The first CPUs that used a cache had only one level of cache; unlike later level 1 caches, it was not split into L1d (for data) and L1i (for instructions). Almost all current CPUs with caches have a split L1 cache. They also have L2 caches and, for larger processors, L3 caches as well. The L2 cache is usually not split and acts as a common repository for the already split L1 cache. Every core of amulti-core processorhas a dedicated L2 cache and is usually not shared between the cores. The L3 cache, and higher-level caches, are shared between the cores and are not split. An L4 cache is currently uncommon, and is generally ondynamic random-access memory(DRAM), rather than onstatic random-access memory(SRAM), on a separate die or chip. That was also the case historically with L1, while bigger chips have allowed integration of it and generally all cache levels, with the possible exception of the last level. Each extra level of cache tends to be bigger and be optimized differently.
Other types of caches exist (that are not counted towards the "cache size" of the most important caches mentioned above), such as thetranslation lookaside buffer(TLB) that is part of thememory management unit(MMU) that most CPUs have.
Caches are generally sized in powers of two: 2, 8, 16 etc.
KiBorMiB(for larger non-L1) sizes, although theIBM z13has a 96 KiB L1 instruction cache.
[66]Clock rate[edit]Most CPUs aresynchronous circuits, which means they employ aclock signalto pace their sequential operations. The clock signal is produced by an externaloscillator circuitthat generates a consistent number of pulses each second in the form of a periodicsquare wave. The frequency of the clock pulses determines the rate at which a CPU executes instructions and, consequently, the faster the clock, the more instructions the CPU will execute each second.
To ensure proper operation of the CPU, the clock period is longer than the maximum time needed for all signals to propagate (move) through the CPU. In setting the clock period to a value well above the worst-casepropagation delay, it is possible to design the entire CPU and the way it moves data around the "edges" of the rising and falling clock signal. This has the advantage of simplifying the CPU significantly, both from a design perspective and a component-count perspective. However, it also carries the disadvantage that the entire CPU must wait on its slowest elements, even though some portions of it are much faster. This limitation has largely been compensated for by various methods of increasing CPU parallelism (see below).
However, architectural improvements alone do not solve all of the drawbacks of globally synchronous CPUs. For example, a clock signal is subject to the delays of any other electrical signal. Higher clock rates in increasingly complex CPUs make it more difficult to keep the clock signal in phase (synchronized) throughout the entire unit. This has led many modern CPUs to require multiple identical clock signals to be provided to avoid delaying a single signal significantly enough to cause the CPU to malfunction. Another major issue, as clock rates increase dramatically, is the amount of heat that isdissipated by the CPU. The constantly changing clock causes many components to switch regardless of whether they are being used at that time. In general, a component that is switching uses more energy than an element in a static state. Therefore, as clock rate increases, so does energy consumption, causing the CPU to require moreheat dissipationin the form ofCPU coolingsolutions.
One method of dealing with the switching of unneeded components is calledclock gating, which involves turning off the clock signal to unneeded components (effectively disabling them). However, this is often regarded as difficult to implement and therefore does not see common usage outside of very low-power designs. One notable recent CPU design that uses extensive clock gating is the IBMPowerPC-basedXenonused in theXbox 360; that way, power requirements of the Xbox 360 are greatly reduced.
[67]Clockless CPUs[edit]Another method of addressing some of the problems with a global clock signal is the removal of the clock signal altogether. While removing the global clock signal makes the design process considerably more complex in many ways, asynchronous (or clockless) designs carry marked advantages in power consumption andheat dissipationin comparison with similar synchronous designs. While somewhat uncommon, entireasynchronous CPUshave been built without using a global clock signal. Two notable examples of this are theARMcompliantAMULETand theMIPSR3000 compatible MiniMIPS.
[68]Rather than totally removing the clock signal, some CPU designs allow certain portions of the device to be asynchronous, such as using asynchronousALUsin conjunction with superscalar pipelining to achieve some arithmetic performance gains. While it is not altogether clear whether totally asynchronous designs can perform at a comparable or better level than their synchronous counterparts, it is evident that they do at least excel in simpler math operations. This, combined with their excellent power consumption and heat dissipation properties, makes them very suitable forembedded computers.
[69]Voltage regulator module[edit]Many modern CPUs have a die-integrated power managing module which regulates on-demand voltage supply to the CPU circuitry allowing it to keep balance between performance and power consumption.
Integer range[edit]Every CPU represents numerical values in a specific way. For example, some early digital computers represented numbers as familiardecimal(base 10)numeral systemvalues, and others have employed more unusual representations such asternary(base three). Nearly all modern CPUs represent numbers inbinaryform, with each digit being represented by some two-valued physical quantity such as a "high" or "low"voltage.
[f]Related to numeric representation is the size and precision of integer numbers that a CPU can represent. In the case of a binary CPU, this is measured by the number of bits (significant digits of a binary encoded integer) that the CPU can process in one operation, which is commonly calledword size,bit width,data path width,integer precision, orinteger size. A CPU's integer size determines the range of integer values it can directly operate on.
[g]For example, an8-bitCPU can directly manipulate integers represented by eight bits, which have a range of 256 (28) discrete integer values.
Integer range can also affect the number of memory locations the CPU can directly address (an address is an integer value representing a specific memory location). For example, if a binary CPU uses 32 bits to represent a memory address then it can directly address 232memory locations. To circumvent this limitation and for various other reasons, some CPUs use mechanisms (such asbank switching) that allow additional memory to be addressed.
CPUs with larger word sizes require more circuitry and consequently are physically larger, cost more and consume more power (and therefore generate more heat). As a result, smaller 4- or 8-bitmicrocontrollersare commonly used in modern applications even though CPUs with much larger word sizes (such as 16, 32, 64, even 128-bit) are available. When higher performance is required, however, the benefits of a larger word size (larger data ranges and address spaces) may outweigh the disadvantages. A CPU can have internal data paths shorter than the word size to reduce size and cost. For example, even though theIBM System/360instruction setwas a 32-bit instruction set, the System/360Model 30andModel 40had 8-bit data paths in the arithmetic logical unit, so that a 32-bit add required four cycles, one for each 8 bits of the operands, and, even though theMotorola 68000 seriesinstruction set was a 32-bit instruction set, theMotorola 68000andMotorola 68010had 16-bit data paths in the arithmetic logical unit, so that a 32-bit add required two cycles.
To gain some of the advantages afforded by both lower and higher bit lengths, manyinstruction setshave different bit widths for integer and floating-point data, allowing CPUs implementing that instruction set to have different bit widths for different portions of the device. For example, the IBMSystem/360instruction set was primarily 32 bit, but supported 64-bitfloating pointvalues to facilitate greater accuracy and range in floating point numbers.
[30]The System/360 Model 65 had an 8-bit adder for decimal and fixed-point binary arithmetic and a 60-bit adder for floating-point arithmetic.
[70]Many later CPU designs use similar mixed bit width, especially when the processor is meant for general-purpose usage where a reasonable balance of integer and floating point capability is required.
Parallelism[edit]The description of the basic operation of a CPU offered in the previous section describes the simplest form that a CPU can take. This type of CPU, usually referred to assubscalar, operates on and executes one instruction on one or two pieces of data at a time, that is less than oneinstruction per clock cycle(IPC < 1).
This process gives rise to an inherent inefficiency in subscalar CPUs. Since only one instruction is executed at a time, the entire CPU must wait for that instruction to complete before proceeding to the next instruction. As a result, the subscalar CPU gets "hung up" on instructions which take more than one clock cycle to complete execution. Even adding a secondexecution unit(see below) does not improve performance much; rather than one pathway being hung up, now two pathways are hung up and the number of unused transistors is increased. This design, wherein the CPU's execution resources can operate on only one instruction at a time, can only possibly reachscalarperformance (one instruction per clock cycle,IPC = 1). However, the performance is nearly always subscalar (less than one instruction per clock cycle,IPC < 1).
Attempts to achieve scalar and better performance have resulted in a variety of design methodologies that cause the CPU to behave less linearly and more in parallel. When referring to parallelism in CPUs, two terms are generally used to classify these design techniques:Each methodology differs both in the ways in which they are implemented, as well as the relative effectiveness they afford in increasing the CPU's performance for an application.
[h]Instruction-level parallelism[edit]One of the simplest methods for increased parallelism is to begin the first steps of instruction fetching and decoding before the prior instruction finishes executing. This is a technique known asinstruction pipelining, and is used in almost all modern general-purpose CPUs. Pipelining allows multiple instruction to be executed at a time by breaking the execution pathway into discrete stages. This separation can be compared to an assembly line, in which an instruction is made more complete at each stage until it exits the execution pipeline and is retired.
Pipelining does, however, introduce the possibility for a situation where the result of the previous operation is needed to complete the next operation; a condition often termed data dependency conflict. Therefore pipelined processors must check for these sorts of conditions and delay a portion of the pipeline if necessary. A pipelined processor can become very nearly scalar, inhibited only by pipeline stalls (an instruction spending more than one clock cycle in a stage).
Improvements in instruction pipelining led to further decreases in the idle time of CPU components. Designs that are said to be superscalar include a long instruction pipeline and multiple identicalexecution units, such asload–store units,arithmetic–logic units,floating-point unitsandaddress generation units.
[71]In a superscalar pipeline, instructions are read and passed to a dispatcher, which decides whether or not the instructions can be executed in parallel (simultaneously). If so, they are dispatched to execution units, resulting in their simultaneous execution. In general, the number of instructions that a superscalar CPU will complete in a cycle is dependent on the number of instructions it is able to dispatch simultaneously to execution units.
Most of the difficulty in the design of a superscalar CPU architecture lies in creating an effective dispatcher. The dispatcher needs to be able to quickly determine whether instructions can be executed in parallel, as well as dispatch them in such a way as to keep as many execution units busy as possible. This requires that the instruction pipeline is filled as often as possible and requires significant amounts ofCPU cache. It also makeshazard-avoiding techniques likebranch prediction,speculative execution,register renaming,out-of-order executionandtransactional memorycrucial to maintaining high levels of performance. By attempting to predict which branch (or path) a conditional instruction will take, the CPU can minimize the number of times that the entire pipeline must wait until a conditional instruction is completed. Speculative execution often provides modest performance increases by executing portions of code that may not be needed after a conditional operation completes. Out-of-order execution somewhat rearranges the order in which instructions are executed to reduce delays due to data dependencies. Also in case ofsingle instruction stream, multiple data stream—a case when a lot of data from the same type has to be processed—, modern processors can disable parts of the pipeline so that when a single instruction is executed many times, the CPU skips the fetch and decode phases and thus greatly increases performance on certain occasions, especially in highly monotonous program engines such as video creation software and photo processing.
In the case where just a portion of the CPU is superscalar, the part which is not suffers a performance penalty due to scheduling stalls. The IntelP5Pentiumhad two superscalar ALUs which could accept one instruction per clock cycle each, but its FPU could not. Thus the P5 was integer superscalar but not floating point superscalar. Intel's successor to the P5 architecture,P6, added superscalar abilities to its floating point features.
Simple pipelining and superscalar design increase a CPU's ILP by allowing it to execute instructions at rates surpassing one instruction per clock cycle. Most modern CPU designs are at least somewhat superscalar, and nearly all general purpose CPUs designed in the last decade are superscalar. In later years some of the emphasis in designing high-ILP computers has been moved out of the CPU's hardware and into its software interface, orinstruction set architecture(ISA). The strategy of thevery long instruction word(VLIW) causes some ILP to become implied directly by the software, reducing the CPU’s work in boosting ILP and thereby reducing design complexity.
Task-level parallelism[edit]Another strategy of achieving performance is to execute multiplethreadsorprocessesin parallel. This area of research is known asparallel computing.
[72]InFlynn's taxonomy, this strategy is known asmultiple instruction stream, multiple data stream(MIMD).
[73]One technology used for this purpose wasmultiprocessing(MP).
[74]The initial flavor of this technology is known assymmetric multiprocessing(SMP), where a small number of CPUs share a coherent view of their memory system. In this scheme, each CPU has additional hardware to maintain a constantly up-to-date view of memory. By avoiding stale views of memory, the CPUs can cooperate on the same program and programs can migrate from one CPU to another. To increase the number of cooperating CPUs beyond a handful, schemes such asnon-uniform memory access(NUMA) anddirectory-based coherence protocolswere introduced in the 1990s. SMP systems are limited to a small number of CPUs while NUMA systems have been built with thousands of processors. Initially, multiprocessing was built using multiple discrete CPUs and boards to implement the interconnect between the processors. When the processors and their interconnect are all implemented on a single chip, the technology is known as chip-level multiprocessing (CMP) and the single chip as amulti-core processor.
It was later recognized that finer-grain parallelism existed with a single program. A single program might have several threads (or functions) that could be executed separately or in parallel. Some of the earliest examples of this technology implementedinput/outputprocessing such asdirect memory accessas a separate thread from the computation thread. A more general approach to this technology was introduced in the 1970s when systems were designed to run multiple computation threads in parallel. This technology is known asmulti-threading(MT). This approach is considered more cost-effective than multiprocessing, as only a small number of components within a CPU is replicated to support MT as opposed to the entire CPU in the case of MP. In MT, the execution units and the memory system including the caches are shared among multiple threads. The downside of MT is that the hardware support for multithreading is more visible to software than that of MP and thus supervisor software like operating systems have to undergo larger changes to support MT. One type of MT that was implemented is known astemporal multithreading, where one thread is executed until it is stalled waiting for data to return from external memory. In this scheme, the CPU would then quickly context switch to another thread which is ready to run, the switch often done in one CPU clock cycle, such as theUltraSPARC T1. Another type of MT issimultaneous multithreading, where instructions from multiple threads are executed in parallel within one CPU clock cycle.
For several decades from the 1970s to early 2000s, the focus in designing high performance general purpose CPUs was largely on achieving high ILP through technologies such as pipelining, caches, superscalar execution, out-of-order execution, etc. This trend culminated in large, power-hungry CPUs such as the IntelPentium 4. By the early 2000s, CPU designers were thwarted from achieving higher performance from ILP techniques due to the growing disparity between CPU operating frequencies and main memory operating frequencies as well as escalating CPU power dissipation owing to more esoteric ILP techniques.
CPU designers then borrowed ideas from commercial computing markets such astransaction processing, where the aggregate performance of multiple programs, also known asthroughputcomputing, was more important than the performance of a single thread or process.
This reversal of emphasis is evidenced by the proliferation of dual and more core processor designs and notably, Intel's newer designs resembling its less superscalarP6architecture. Late designs in several processor families exhibit CMP, including thex86-64OpteronandAthlon 64 X2, theSPARCUltraSPARC T1, IBMPOWER4andPOWER5, as well as severalvideo game consoleCPUs like theXbox 360's triple-core PowerPC design, and thePlayStation 3's 7-coreCell microprocessor.
Data parallelism[edit]A less common but increasingly important paradigm of processors (and indeed, computing in general) deals with data parallelism. The processors discussed earlier are all referred to as some type of scalar device.
[i]As the name implies, vector processors deal with multiple pieces of data in the context of one instruction. This contrasts with scalar processors, which deal with one piece of data for every instruction. UsingFlynn's taxonomy, these two schemes of dealing with data are generally referred to assingle instructionstream,multiple datastream (SIMD) andsingle instructionstream,single datastream (SISD), respectively. The great utility in creating processors that deal with vectors of data lies in optimizing tasks that tend to require the same operation (for example, a sum or adot product) to be performed on a large set of data. Some classic examples of these types of tasks includemultimediaapplications (images, video and sound), as well as many types ofscientificand engineering tasks. Whereas a scalar processor must complete the entire process of fetching, decoding and executing each instruction and value in a set of data, a vector processor can perform a single operation on a comparatively large set of data with one instruction. This is only possible when the application tends to require many steps which apply one operation to a large set of data.
Most early vector processors, such as theCray-1, were associated almost exclusively with scientific research andcryptographyapplications. However, as multimedia has largely shifted to digital media, the need for some form of SIMD in general-purpose processors has become significant. Shortly after inclusion offloating-point unitsstarted to become commonplace in general-purpose processors, specifications for and implementations of SIMD execution units also began to appear for general-purpose processors.
[when?]Some of these early SIMD specifications - like HP'sMultimedia Acceleration eXtensions(MAX) and Intel'sMMX- were integer-only. This proved to be a significant impediment for some software developers, since many of the applications that benefit from SIMD primarily deal withfloating-pointnumbers. Progressively, developers refined and remade these early designs into some of the common modern SIMD specifications, which are usually associated with oneinstruction set architecture(ISA). Some notable modern examples include Intel'sStreaming SIMD Extensions(SSE) and the PowerPC-relatedAltiVec(also known as VMX).
[j]Hardware performance counter[edit]Many modern architectures (including embedded ones) often includehardware performance counters(HPC), which enables low-level (instruction-level) collection,benchmarking, debugging or analysis of running software metrics.
[75][76]HPC may also be used to discover and analyze unusual or suspicious activity of the software, such asreturn-oriented programming(ROP) orsigreturn-oriented programming(SROP) exploits etc.
[77]This is usually done by software-security teams to assess and find malicious binary programs.
Many major vendors (such as IBM, Intel, AMD, and ARM etc.) provide software interfaces (usually written in C/C++) that can be used to collected data from CPUsregistersin order to get metrics.
[78]Operating system vendors also provide software likeperf(Linux) to record,benchmark, ortraceCPU events running kernels and applications.
Virtual CPUs[edit]Cloud computingcan involve subdividing CPU operation intovirtual central processing units[79](vCPUs[80]).
A host is the virtual equivalent of a physical machine, on which a virtual system is operating.
[81]When there are several physical machines operating in tandem and managed as a whole, the grouped computing and memory resources form acluster. In some systems, it is possible to dynamically add and remove from a cluster. Resources available at a host and cluster level can be partitioned out intoresources poolswith finegranularity.
Performance[edit]Theperformanceorspeedof a processor depends on, among many other factors, the clock rate (generally given in multiples ofhertz) and the instructions per clock (IPC), which together are the factors for theinstructions per second(IPS) that the CPU can perform.
[82]Many reported IPS values have represented "peak" execution rates on artificial instruction sequences with few branches, whereas realistic workloads consist of a mix of instructions and applications, some of which take longer to execute than others. The performance of thememory hierarchyalso greatly affects processor performance, an issue barely considered in MIPS calculations. Because of these problems, various standardized tests, often called"benchmarks"for this purpose‍—‌such asSPECint‍—‌have been developed to attempt to measure the real effective performance in commonly used applications.
Processing performance of computers is increased by usingmulti-core processors, which essentially is plugging two or more individual processors (calledcoresin this sense) into one integrated circuit.
[83]Ideally, a dual core processor would be nearly twice as powerful as a single core processor. In practice, the performance gain is far smaller, only about 50%, due to imperfect software algorithms and implementation.
[84]Increasing the number of cores in a processor (i.e. dual-core, quad-core, etc.) increases the workload that can be handled. This means that the processor can now handle numerous asynchronous events, interrupts, etc. which can take a toll on the CPU when overwhelmed. These cores can be thought of as different floors in a processing plant, with each floor handling a different task. Sometimes, these cores will handle the same tasks as cores adjacent to them if a single core is not enough to handle the information.
Due to specific capabilities of modern CPUs, such assimultaneous multithreadinganduncore, which involve sharing of actual CPU resources while aiming at increased utilization, monitoring performance levels and hardware use gradually became a more complex task.
[85]As a response, some CPUs implement additional hardware logic that monitors actual use of various parts of a CPU and provides various counters accessible to software; an example is Intel'sPerformance Counter Monitortechnology.
[2]See also[edit]Notes[edit]References[edit]External links[edit]Navigation menuSearch
