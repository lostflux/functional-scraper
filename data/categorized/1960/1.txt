old id = 1163
Stochastic gradient descent - Wikipedia
1960
https://en.wikipedia.org/wiki/Stochastic_gradient_descent

Stochastic gradient descentStochastic gradient descent(often abbreviatedSGD) is an iterative method for optimizing anobjective functionwith suitablesmoothnessproperties (e.g.
differentiableorsubdifferentiable). It can be regarded as astochastic approximationofgradient descentoptimization, since it replaces the actual gradient (calculated from the entiredata set) by an estimate thereof (calculated from a randomly selected subset of the data). Especially inhigh-dimensionaloptimization problems this reduces the very highcomputational burden, achieving faster iterations in trade for a lower convergence rate.
[1]While the basic idea behind stochastic approximation can be traced back to theRobbins–Monro algorithmof the 1950s, stochastic gradient descent has become an important optimization method inmachine learning.
[2]ContentsBackground[edit]Bothstatisticalestimationandmachine learningconsider the problem ofminimizinganobjective functionthat has the form of a sum:where theparameterw{\displaystyle w}that minimizesQ(w){\displaystyle Q(w)}is to beestimated. Each summand functionQi{\displaystyle Q_{i}}is typically associated with thei{\displaystyle i}-thobservationin thedata set(used for training).
In classical statistics, sum-minimization problems arise inleast squaresand inmaximum-likelihood estimation(for independent observations). The general class of estimators that arise as minimizers of sums are calledM-estimators. However, in statistics, it has been long recognized that requiring even local minimization is too restrictive for some problems of maximum-likelihood estimation.
[3]Therefore, contemporary statistical theorists often considerstationary pointsof thelikelihood function(or zeros of its derivative, thescore function, and otherestimating equations).
The sum-minimization problem also arises forempirical risk minimization. In this case,Qi(w){\displaystyle Q_{i}(w)}is the value of theloss functionati{\displaystyle i}-th example, andQ(w){\displaystyle Q(w)}is the empirical risk.
When used to minimize the above function, a standard (or "batch")gradient descentmethod would perform the following iterations:whereη{\displaystyle \eta }is a step size (sometimes called thelearning ratein machine learning).
In many cases, the summand functions have a simple form that enables inexpensive evaluations of the sum-function and the sum gradient. For example, in statistics,one-parameter exponential familiesallow economical function-evaluations and gradient-evaluations.
However, in other cases, evaluating the sum-gradient may require expensive evaluations of the gradients from all summand functions. When the training set is enormous and no simple formulas exist, evaluating the sums of gradients becomes very expensive, because evaluating the gradient requires evaluating all the summand functions' gradients. To economize on the computational cost at every iteration, stochastic gradient descentsamplesa subset of summand functions at every step. This is very effective in the case of large-scale machine learning problems.
[4]Iterative method[edit]In stochastic (or "on-line") gradient descent, the true gradient ofQ(w){\displaystyle Q(w)}is approximated by a gradient at a single sample:As the algorithm sweeps through the training set, it performs the above update for each training sample. Several passes can be made over the training set until the algorithm converges. If this is done, the data can be shuffled for each pass to prevent cycles. Typical implementations may use anadaptive learning rateso that the algorithm converges.
[5]In pseudocode, stochastic gradient descent can be presented as :A compromise between computing the true gradient and the gradient at a single sample is to compute the gradient against more than one training sample (called a "mini-batch") at each step. This can perform significantly better than "true" stochastic gradient descent described, because the code can make use ofvectorizationlibraries rather than computing each step separately as was first shown in[6]where it was called "the bunch-mode back-propagation algorithm". It may also result in smoother convergence, as the gradient computed at each step is averaged over more training sample.
The convergence of stochastic gradient descent has been analyzed using the theories ofconvex minimizationand ofstochastic approximation. Briefly, when thelearning ratesη{\displaystyle \eta }decrease with an appropriate rate, and subject to relatively mild assumptions, stochastic gradient descent convergesalmost surelyto a global minimum when the objective function isconvexorpseudoconvex, and otherwise converges almost surely to a local minimum.
[7][8]This is in fact a consequence of theRobbins–Siegmund theorem.
[9]Example[edit]Let's suppose we want to fit a straight liney^=w1+w2x{\displaystyle {\hat {y}}=\!w_{1}+w_{2}x}to a training set with observations(x1,x2,…,xn){\displaystyle (x_{1},x_{2},\ldots ,x_{n})}and corresponding estimated responses(y1^,y2^,…,yn^){\displaystyle ({\hat {y_{1}}},{\hat {y_{2}}},\ldots ,{\hat {y_{n}}})}usingleast squares. The objective function to be minimized is:The last line in the above pseudocode for this specific problem will become:Note that in each iteration (also called update), the gradient is only evaluated at a single pointxi{\displaystyle x_{i}}instead of at the set of all samples.
The key difference compared to standard (Batch) Gradient Descent is that only one piece of data from the dataset is used to calculate the step, and the piece of data is picked randomly at each step.
Notable applications[edit]Stochastic gradient descent is a popular algorithm for training a wide range of models inmachine learning, including (linear)support vector machines,logistic regression(see, e.g.,Vowpal Wabbit) andgraphical models.
[10]When combined with thebackpropagationalgorithm, it is thede factostandard algorithm for trainingartificial neural networks.
[11]Its use has been also reported in theGeophysicscommunity, specifically to applications of Full Waveform Inversion (FWI).
[12]Stochastic gradient descent competes with theL-BFGSalgorithm,[citation needed]which is also widely used. Stochastic gradient descent has been used since at least 1960 for traininglinear regressionmodels, originally under the nameADALINE.
[13]Another stochastic gradient descent algorithm is theleast mean squares (LMS)adaptive filter.
Extensions and variants[edit]Many improvements on the basic stochastic gradient descent algorithm have been proposed and used. In particular, in machine learning, the need to set alearning rate(step size) has been recognized as problematic. Setting this parameter too high can cause the algorithm to diverge; setting it too low makes it slow to converge.
[14]A conceptually simple extension of stochastic gradient descent makes the learning rate a decreasing functionηtof the iteration numbert, giving alearning rate schedule, so that the first iterations cause large changes in the parameters, while the later ones do only fine-tuning. Such schedules have been known since the work of MacQueen onk-means clustering.
[15]Practical guidance on choosing the step size in several variants of SGD is given by Spall.
[16]Implicit updates (ISGD)[edit]As mentioned earlier, classical stochastic gradient descent is generally sensitive tolearning rateη. Fast convergence requires large learning rates but this may induce numerical instability. The problem can be largely solved[17]by consideringimplicit updateswhereby the stochastic gradient is evaluated at the next iterate rather than the current one:This equation is implicit sincewnew{\displaystyle w^{\rm {new}}}appears on both sides of the equation. It is a stochastic form of theproximal gradient methodsince the update can also be written as:As an example, consider least squares with featuresx1,…,xn∈Rp{\displaystyle x_{1},\ldots ,x_{n}\in \mathbb {R} ^{p}}and observationsy1,…,yn∈R{\displaystyle y_{1},\ldots ,y_{n}\in \mathbb {R} }. We wish to solve:wherexj′w=xj1w1+xj,2w2+.
.
.
+xj,pwp{\displaystyle x_{j}'w=x_{j1}w_{1}+x_{j,2}w_{2}+...+x_{j,p}w_{p}}indicates the inner product. Note thatx{\displaystyle x}could have "1" as the first element to include an intercept. Classical stochastic gradient descent proceeds as follows:wherei{\displaystyle i}is uniformly sampled between 1 andn{\displaystyle n}. Although theoretical convergence of this procedure happens under relatively mild assumptions, in practice the procedure can be quite unstable. In particular, whenη{\displaystyle \eta }is misspecified so thatI−ηxixi′{\displaystyle I-\eta x_{i}x_{i}'}has large absolute eigenvalues with high probability, the procedure may diverge numerically within a few iterations. In contrast,implicit stochastic gradient descent(shortened as ISGD) can be solved in closed-form as:This procedure will remain numerically stable virtually for allη{\displaystyle \eta }as thelearning rateis now normalized. Such comparison between classical and implicit stochastic gradient descent in the least squares problem is very similar to the comparison betweenleast mean squares (LMS)andnormalized least mean squares filter (NLMS).
Even though a closed-form solution for ISGD is only possible in least squares, the procedure can be efficiently implemented in a wide range of models. Specifically, suppose thatQi(w){\displaystyle Q_{i}(w)}depends onw{\displaystyle w}only through a linear combination with featuresxi{\displaystyle x_{i}}, so that we can write∇wQi(w)=−q(xi′w)xi{\displaystyle \nabla _{w}Q_{i}(w)=-q(x_{i}'w)x_{i}}, whereq()∈R{\displaystyle q()\in \mathbb {R} }may depend onxi,yi{\displaystyle x_{i},y_{i}}as well but not onw{\displaystyle w}except throughxi′w{\displaystyle x_{i}'w}. Least squares obeys this rule, and so doeslogistic regression, and mostgeneralized linear models. For instance, in least squares,q(xi′w)=yi−xi′w{\displaystyle q(x_{i}'w)=y_{i}-x_{i}'w}, and in logistic regressionq(xi′w)=yi−S(xi′w){\displaystyle q(x_{i}'w)=y_{i}-S(x_{i}'w)}, whereS(u)=eu/(1+eu){\displaystyle S(u)=e^{u}/(1+e^{u})}is thelogistic function. InPoisson regression,q(xi′w)=yi−exi′w{\displaystyle q(x_{i}'w)=y_{i}-e^{x_{i}'w}}, and so on.
In such settings, ISGD is simply implemented as follows. Letf(ξ)=ηq(xi′wold+ξ||xi||2){\displaystyle f(\xi )=\eta q(x_{i}'w^{old}+\xi ||x_{i}||^{2})}, whereξ{\displaystyle \xi }is scalar. Then, ISGD is equivalent to:The scaling factorξ∗∈R{\displaystyle \xi ^{\ast }\in \mathbb {R} }can be found through thebisection methodsince in most regular models, such as the aforementioned generalized linear models, functionq(){\displaystyle q()}is decreasing, and thus the search bounds forξ∗{\displaystyle \xi ^{\ast }}are[min(0,f(0)),max(0,f(0))]{\displaystyle [\min(0,f(0)),\max(0,f(0))]}.
Momentum[edit]Further proposals include themomentum method, which appeared inRumelhart,HintonandWilliams' paper on backpropagation learning.
[18]Stochastic gradient descent with momentum remembers the updateΔwat each iteration, and determines the next update as alinear combinationof the gradient and the previous update:[19][20]that leads to:where theparameterw{\displaystyle w}which minimizesQ(w){\displaystyle Q(w)}is to beestimated,η{\displaystyle \eta }is a step size (sometimes called thelearning ratein machine learning) andα{\displaystyle \alpha }is an exponentialdecay factorbetween 0 and 1 that determines the relative contribution of the current gradient and earlier gradients to the weight change.
The name momentum stems from an analogy tomomentumin physics: the weight vectorw{\displaystyle w}, thought of as a particle traveling through parameter space,[18]incurs acceleration from the gradient of the loss ("force"). Unlike in classical stochastic gradient descent, it tends to keep traveling in the same direction, preventing oscillations. Momentum has been used successfully by computer scientists in the training ofartificial neural networksfor several decades.
[21]Themomentum methodis closely related tounderdamped Langevin dynamics, and may be combined withSimulated Annealing.
[22]Averaging[edit]Averaged stochastic gradient descent, invented independently by Ruppert and Polyak in the late 1980s, is ordinary stochastic gradient descent that records an average of its parameter vector over time. That is, the update is the same as for ordinary stochastic gradient descent, but the algorithm also keeps track of[23]When optimization is done, this averaged parameter vector takes the place ofw.
AdaGrad[edit]AdaGrad(for adaptivegradientalgorithm) is a modified stochastic gradient descent algorithm with per-parameterlearning rate, first published in 2011.
[24]Informally, this increases the learning rate for sparser parameters and decreases the learning rate for ones that are less sparse. This strategy often improves convergence performance over standard stochastic gradient descent in settings where data is sparse and sparse parameters are more informative. Examples of such applications include natural language processing and image recognition.
[24]It still has a base learning rateη, but this is multiplied with the elements of a vector{Gj,j}which is the diagonal of theouter productmatrixwheregτ=∇Qi(w){\displaystyle g_{\tau }=\nabla Q_{i}(w)}, the gradient, at iterationτ. The diagonal is given byThis vector is updated after every iteration. The formula for an update is nowor, written as per-parameter updates,Each{G(i,i)}gives rise to a scaling factor for the learning rate that applies to a single parameterwi. Since the denominator in this factor,Gi=∑τ=1tgτ2{\displaystyle {\sqrt {G_{i}}}={\sqrt {\sum _{\tau =1}^{t}g_{\tau }^{2}}}}is theℓ2normof previous derivatives, extreme parameter updates get dampened, while parameters that get few or small updates receive higher learning rates.
[21]While designed forconvex problems, AdaGrad has been successfully applied to non-convex optimization.
[25]RMSProp[edit]RMSProp(for Root Mean Square Propagation) is also a method in which thelearning rateis adapted for each of the parameters. The idea is to divide the learning rate for a weight by a running average of the magnitudes of recent gradients for that weight.
[26]So, first the running average is calculated in terms of means square,where,γ{\displaystyle \gamma }is the forgetting factor.
And the parameters are updated as,RMSProp has shown good adaptation of learning rate in different applications. RMSProp can be seen as a generalization ofRpropand is capable to work with mini-batches as well opposed to only full-batches.
[27]Adam[edit]Adam[28](short for Adaptive Moment Estimation) is an update to theRMSPropoptimizer. In this optimization algorithm, running averages of both the gradients and the second moments of the gradients are used. Given parametersw(t){\displaystyle w^{(t)}}and a loss functionL(t){\displaystyle L^{(t)}}, wheret{\displaystyle t}indexes the current training iteration (indexed at0{\displaystyle 0}), Adam's parameter update is given by:whereϵ{\displaystyle \epsilon }is a small scalar (e.g.
10−8{\displaystyle 10^{-8}}) used to prevent division by 0, andβ1{\displaystyle \beta _{1}}(e.g. 0.9) andβ2{\displaystyle \beta _{2}}(e.g. 0.999) are the forgetting factors for gradients and second moments of gradients, respectively. Squaring and square-rooting is done element-wise.
Backtracking line search[edit]Backtracking line searchis another variant of gradient descent. All of the below are sourced from the mentioned link. It is based on a condition known as the Armijo–Goldstein condition. Both methods allow learning rates to change at each iteration; however, the manner of the change is different. Backtracking line search uses function evaluations to check Armijo's condition, and in principle the loop in the algorithm for determining the learning rates can be long and unknown in advance. Adaptive SGD does not need a loop in determining learning rates. On the other hand, adaptive SGD does not guarantee the "descent property" – which Backtracking line search enjoys – which is thatf(xn+1)≤f(xn){\displaystyle f(x_{n+1})\leq f(x_{n})}for all n. If the gradient of the cost function is globally Lipschitz continuous, with Lipschitz constant L, and learning rate is chosen of the order 1/L, then the standard version of SGD is a special case of backtracking line search.
Second-order methods[edit]A stochastic analogue of the standard (deterministic) Newton–Raphson algorithm (a "second-order" method) provides an asymptotically optimal or near-optimal form of iterative optimization in the setting of stochastic approximation[citation needed]. A method that uses direct measurements of theHessian matricesof the summands in the empirical risk function was developed by Byrd, Hansen, Nocedal, and Singer.
[29]However, directly determining the required Hessian matrices for optimization may not be possible in practice. Practical and theoretically sound methods for second-order versions of SGD that do not require direct Hessian information are given by Spall and others.
[30][31][32](A less efficient method based on finite differences, instead of simultaneous perturbations, is given by Ruppert.
[33]) These methods not requiring direct Hessian information are based on either values of the summands in the above empirical risk function or values of the gradients of the summands (i.e., the SGD inputs). In particular, second-order optimality is asymptotically achievable without direct calculation of the Hessian matrices of the summands in the empirical risk function.
Notes[edit]See also[edit]References[edit]Further reading[edit]External links[edit]Navigation menuSearch
