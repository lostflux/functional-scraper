old id = 1160
Reinforcement learning - Wikipedia
unknown
https://en.wikipedia.org/wiki/Reinforcement_learning

Reinforcement learningReinforcement learning(RL) is an area ofmachine learningconcerned with howintelligent agentsought to takeactionsin an environment in order to maximize the notion of cumulative reward. Reinforcement learning is one of three basic machine learning paradigms, alongsidesupervised learningandunsupervised learning.
Reinforcement learning differs from supervised learning in not needing labelled input/output pairs be presented, and in not needing sub-optimal actions to be explicitly corrected. Instead the focus is on finding a balance between exploration (of uncharted territory) and exploitation (of current knowledge).
[1]Partially supervised RL algorithms can combine the advantages of supervised and RL algorithms.
[2]The environment is typically stated in the form of aMarkov decision process(MDP), because many reinforcement learning algorithms for this context usedynamic programmingtechniques.
[3]The main difference between the classical dynamic programming methods and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the MDP and they target large MDPs where exact methods become infeasible.
.mw-parser-output .toclimit-2 .toclevel-1 ul,.mw-parser-output .toclimit-3 .toclevel-2 ul,.mw-parser-output .toclimit-4 .toclevel-3 ul,.mw-parser-output .toclimit-5 .toclevel-4 ul,.mw-parser-output .toclimit-6 .toclevel-5 ul,.mw-parser-output .toclimit-7 .toclevel-6 ul{display:none}ContentsIntroduction[edit]Due to its generality, reinforcement learning is studied in many disciplines, such asgame theory,control theory,operations research,information theory,simulation-based optimization,multi-agent systems,swarm intelligence, andstatistics. In the operations research and control literature, reinforcement learning is calledapproximate dynamic programming,orneuro-dynamic programming.
The problems of interest in reinforcement learning have also been studied in thetheory of optimal control, which is concerned mostly with the existence and characterization of optimal solutions, and algorithms for their exact computation, and less with learning or approximation, particularly in the absence of a mathematical model of the environment. Ineconomicsandgame theory, reinforcement learning may be used to explain how equilibrium may arise underbounded rationality.
Basic reinforcement is modeled as aMarkov decision process (MDP):The purpose of reinforcement learning is for the agent to learn an optimal, or nearly-optimal, policy that maximizes the "reward function" or other user-provided reinforcement signal that accumulates from the immediate rewards. This is similar to processes that appear to occur in animal psychology. For example, biological brains are hardwired to interpret signals such as pain and hunger as negative reinforcements, and interpret pleasure and food intake as positive reinforcements. In some circumstances, animals can learn to engage in behaviors that optimize these rewards. This suggests that animals are capable of reinforcement learning.
[4][5]A basic reinforcement learning agent AI interacts with its environment in discrete time steps. At each timet, the agent receives the current statest{\displaystyle s_{t}}and rewardrt{\displaystyle r_{t}}. It then chooses an actionat{\displaystyle a_{t}}from the set of available actions, which is subsequently sent to the environment. The environment moves to a new statest+1{\displaystyle s_{t+1}}and the rewardrt+1{\displaystyle r_{t+1}}associated with thetransition(st,at,st+1){\displaystyle (s_{t},a_{t},s_{t+1})}is determined. The goal of a reinforcement learning agent is to learn apolicy:π:A×S→[0,1]{\displaystyle \pi :A\times S\rightarrow [0,1]},π(a,s)=Pr(at=a∣st=s){\displaystyle \pi (a,s)=\Pr(a_{t}=a\mid s_{t}=s)}which maximizes the expected cumulative reward.
Formulating the problem as an MDP assumes the agent directly observes the current environmental state; in this case the problem is said to havefull observability. If the agent only has access to a subset of states, or if the observed states are corrupted by noise, the agent is said to havepartial observability, and formally the problem must be formulated as aPartially observable Markov decision process. In both cases, the set of actions available to the agent can be restricted. For example, the state of an account balance could be restricted to be positive; if the current value of the state is 3 and the state transition attempts to reduce the value by 4, the transition will not be allowed.
When the agent's performance is compared to that of an agent that acts optimally, the difference in performance gives rise to the notion ofregret. In order to act near optimally, the agent must reason about the long-term consequences of its actions (i.e., maximize future income), although the immediate reward associated with this might be negative.
Thus, reinforcement learning is particularly well-suited to problems that include a long-term versus short-term reward trade-off. It has been applied successfully to various problems, includingrobot control,[6]elevator scheduling,telecommunications,backgammon,checkers[7]andGo(AlphaGo).
Two elements make reinforcement learning powerful: the use of samples to optimize performance and the use of function approximation to deal with large environments. Thanks to these two key components, reinforcement learning can be used in large environments in the following situations:The first two of these problems could be considered planning problems (since some form of model is available), while the last one could be considered to be a genuine learning problem. However, reinforcement learning converts both planning problems tomachine learningproblems.
Exploration[edit]The exploration vs. exploitation trade-off has been most thoroughly studied through themulti-armed banditproblem and for finite state space MDPs in Burnetas and Katehakis (1997).
[9]Reinforcement learning requires clever exploration mechanisms; randomly selecting actions, without reference to an estimated probability distribution, shows poor performance. The case of (small) finiteMarkov decision processesis relatively well understood. However, due to the lack of algorithms that scale well with the number of states (or scale to problems with infinite state spaces), simple exploration methods are the most practical.
One such method isε{\displaystyle \varepsilon }-greedy, where0<ε<1{\displaystyle 0<\varepsilon <1}is a parameter controlling the amount of exploration vs. exploitation. With probability1−ε{\displaystyle 1-\varepsilon }, exploitation is chosen, and the agent chooses the action that it believes has the best long-term effect (ties between actions are broken uniformly at random). Alternatively, with probabilityε{\displaystyle \varepsilon }, exploration is chosen, and the action is chosen uniformly at random.
ε{\displaystyle \varepsilon }is usually a fixed parameter but can be adjusted either according to a schedule (making the agent explore progressively less), or adaptively based on heuristics.
[10]Algorithms for control learning[edit]Even if the issue of exploration is disregarded and even if the state was observable (assumed hereafter), the problem remains to use past experience to find out which actions lead to higher cumulative rewards.
Criterion of optimality[edit]Policy[edit]The agent's action selection is modeled as a map calledpolicy:The policy map gives the probability of taking actiona{\displaystyle a}when in states{\displaystyle s}.
[11]: 61There are also deterministic policies.
State-value function[edit]The value functionVπ(s){\displaystyle V_{\pi }(s)}is defined as theexpected returnstarting with states{\displaystyle s}, i.e.
s0=s{\displaystyle s_{0}=s}, and successively following policyπ{\displaystyle \pi }. Hence, roughly speaking, the value function estimates "how good" it is to be in a given state.
[11]: 60where the random variableR{\displaystyle R}denotes thereturn, and is defined as the sum of future discounted rewards:wherert{\displaystyle r_{t}}is the reward at stept{\displaystyle t},γ∈[0,1){\displaystyle \gamma \in [0,1)}is thediscount-rate. Gamma is less than 1, so events in the distant future are weighted less than events in the immediate future.
The algorithm must find a policy with maximum expected return. From the theory of MDPs it is known that, without loss of generality, the search can be restricted to the set of so-calledstationarypolicies. A policy isstationaryif the action-distribution returned by it depends only on the last state visited (from the observation agent's history). The search can be further restricted todeterministicstationary policies. Adeterministic stationarypolicy deterministically selects actions based on the current state. Since any such policy can be identified with a mapping from the set of states to the set of actions, these policies can be identified with such mappings with no loss of generality.
Brute force[edit]Thebrute forceapproach entails two steps:One problem with this is that the number of policies can be large, or even infinite. Another is that the variance of the returns may be large, which requires many samples to accurately estimate the return of each policy.
These problems can be ameliorated if we assume some structure and allow samples generated from one policy to influence the estimates made for others. The two main approaches for achieving this arevalue function estimationanddirect policy search.
Value function[edit]Value function approaches attempt to find a policy that maximizes the return by maintaining a set of estimates of expected returns for some policy (usually either the "current" [on-policy] or the optimal [off-policy] one).
These methods rely on the theory of Markov decision processes, where optimality is defined in a sense that is stronger than the above one: A policy is called optimal if it achieves the best-expected return fromanyinitial state (i.e., initial distributions play no role in this definition). Again, an optimal policy can always be found amongst stationary policies.
To define optimality in a formal manner, define the value of a policyπ{\displaystyle \pi }bywhereR{\displaystyle R}stands for the return associated with followingπ{\displaystyle \pi }from the initial states{\displaystyle s}. DefiningV∗(s){\displaystyle V^{*}(s)}as the maximum possible value ofVπ(s){\displaystyle V^{\pi }(s)}, whereπ{\displaystyle \pi }is allowed to change,A policy that achieves these optimal values in each state is calledoptimal. Clearly, a policy that is optimal in this strong sense is also optimal in the sense that it maximizes the expected returnρπ{\displaystyle \rho ^{\pi }}, sinceρπ=E[Vπ(S)]{\displaystyle \rho ^{\pi }=E[V^{\pi }(S)]}, whereS{\displaystyle S}is a state randomly sampled from the distributionμ{\displaystyle \mu }of initial states (soμ(s)=Pr(s0=s){\displaystyle \mu (s)=\Pr(s_{0}=s)}).
Although state-values suffice to define optimality, it is useful to define action-values. Given a states{\displaystyle s}, an actiona{\displaystyle a}and a policyπ{\displaystyle \pi }, the action-value of the pair(s,a){\displaystyle (s,a)}underπ{\displaystyle \pi }is defined bywhereR{\displaystyle R}now stands for the random return associated with first taking actiona{\displaystyle a}in states{\displaystyle s}and followingπ{\displaystyle \pi }, thereafter.
The theory of MDPs states that ifπ∗{\displaystyle \pi ^{*}}is an optimal policy, we act optimally (take the optimal action) by choosing the action fromQπ∗(s,⋅){\displaystyle Q^{\pi ^{*}}(s,\cdot )}with the highest value at each state,s{\displaystyle s}. Theaction-value functionof such an optimal policy (Qπ∗{\displaystyle Q^{\pi ^{*}}}) is called theoptimal action-value functionand is commonly denoted byQ∗{\displaystyle Q^{*}}. In summary, the knowledge of the optimal action-value function alone suffices to know how to act optimally.
Assuming full knowledge of the MDP, the two basic approaches to compute the optimal action-value function arevalue iterationandpolicy iteration. Both algorithms compute a sequence of functionsQk{\displaystyle Q_{k}}(k=0,1,2,…{\displaystyle k=0,1,2,\ldots }){\displaystyle k=0,1,2,\ldots } that converge toQ∗{\displaystyle Q^{*}}. Computing these functions involves computing expectations over the whole state-space, which is impractical for all but the smallest (finite) MDPs. In reinforcement learning methods, expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large state-action spaces.
Monte Carlo methods[edit]Monte Carlo methodscan be used in an algorithm that mimics policy iteration. Policy iteration consists of two steps:policy evaluationandpolicy improvement.
Monte Carlo is used in the policy evaluation step. In this step, given a stationary, deterministic policyπ{\displaystyle \pi }, the goal is to compute the function valuesQπ(s,a){\displaystyle Q^{\pi }(s,a)}(or a good approximation to them) for all state-action pairs(s,a){\displaystyle (s,a)}. Assuming (for simplicity) that the MDP is finite, that sufficient memory is available to accommodate the action-values and that the problem is episodic and after each episode a new one starts from some random initial state. Then, the estimate of the value of a given state-action pair(s,a){\displaystyle (s,a)}can be computed by averaging the sampled returns that originated from(s,a){\displaystyle (s,a)}over time. Given sufficient time, this procedure can thus construct a precise estimateQ{\displaystyle Q}of the action-value functionQπ{\displaystyle Q^{\pi }}. This finishes the description of the policy evaluation step.
In the policy improvement step, the next policy is obtained by computing agreedypolicy with respect toQ{\displaystyle Q}: Given a states{\displaystyle s}, this new policy returns an action that maximizesQ(s,⋅){\displaystyle Q(s,\cdot )}. In practicelazy evaluationcan defer the computation of the maximizing actions to when they are needed.
Problems with this procedure include:1. The procedure may spend too much time evaluating a suboptimal policy.
2. It uses samples inefficiently in that a long trajectory improves the estimate only of thesinglestate-action pair that started the trajectory.
3. When the returns along the trajectories havehigh variance, convergence is slow.
4. It works inepisodic problemsonly.
5. It works in small, finite MDPs only.
Temporal difference methods[edit]The first problem is corrected by allowing the procedure to change the policy (at some or all states) before the values settle. This too may be problematic as it might prevent convergence. Most current algorithms do this, giving rise to the class ofgeneralized policy iterationalgorithms. Manyactor-criticmethods belong to this category.
The second issue can be corrected by allowing trajectories to contribute to any state-action pair in them. This may also help to some extent with the third problem, although a better solution when returns have high variance is Sutton'stemporal difference(TD) methods that are based on the recursiveBellman equation.
[12][13]The computation in TD methods can be incremental (when after each transition the memory is changed and the transition is thrown away), or batch (when the transitions are batched and the estimates are computed once based on the batch). Batch methods, such as the least-squares temporal difference method,[14]may use the information in the samples better, while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity. Some methods try to combine the two approaches. Methods based on temporal differences also overcome the fourth issue.
In order to address the fifth issue,function approximation methodsare used.
Linear function approximationstarts with a mappingϕ{\displaystyle \phi }that assigns a finite-dimensional vector to each state-action pair. Then, the action values of a state-action pair(s,a){\displaystyle (s,a)}are obtained by linearly combining the components ofϕ(s,a){\displaystyle \phi (s,a)}with someweightsθ{\displaystyle \theta }:The algorithms then adjust the weights, instead of adjusting the values associated with the individual state-action pairs. Methods based on ideas fromnonparametric statistics(which can be seen to construct their own features) have been explored.
Value iteration can also be used as a starting point, giving rise to theQ-learningalgorithm and its many variants.
[15]The problem with using action-values is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy, though this problem is mitigated to some extent by temporal difference methods. Using the so-called compatible function approximation method compromises generality and efficiency. Another problem specific to TD comes from their reliance on the recursive Bellman equation. Most TD methods have a so-calledλ{\displaystyle \lambda }parameter(0≤λ≤1){\displaystyle (0\leq \lambda \leq 1)}that can continuously interpolate between Monte Carlo methods that do not rely on the Bellman equations and the basic TD methods that rely entirely on the Bellman equations. This can be effective in palliating this issue.
Direct policy search[edit]An alternative method is to search directly in (some subset of) the policy space, in which case the problem becomes a case ofstochastic optimization. The two approaches available are gradient-based and gradient-free methods.
Gradient-based methods (policy gradient methods) start with a mapping from a finite-dimensional (parameter) space to the space of policies: given the parameter vectorθ{\displaystyle \theta }, letπθ{\displaystyle \pi _{\theta }}denote the policy associated toθ{\displaystyle \theta }. Defining the performance function byunder mild conditions this function will be differentiable as a function of the parameter vectorθ{\displaystyle \theta }. If the gradient ofρ{\displaystyle \rho }was known, one could usegradient ascent. Since an analytic expression for the gradient is not available, only a noisy estimate is available. Such an estimate can be constructed in many ways, giving rise to algorithms such as Williams' REINFORCE method[16](which is known as the likelihood ratio method in thesimulation-based optimizationliterature).
[17]Policy search methods have been used in theroboticscontext.
[18]Many policy search methods may get stuck in local optima (as they are based onlocal search).
A large class of methods avoids relying on gradient information. These includesimulated annealing,cross-entropy searchor methods ofevolutionary computation. Many gradient-free methods can achieve (in theory and in the limit) a global optimum.
Policy search methods may converge slowly given noisy data. For example, this happens in episodic problems when the trajectories are long and the variance of the returns is large. Value-function based methods that rely on temporal differences might help in this case. In recent years,actor–critic methodshave been proposed and performed well on various problems.
[19]Model-based algorithms[edit]Finally, all of the above methods can be combined with algorithms that first learn a model. For instance, the Dyna algorithm[20]learns a model from experience, and uses that to provide more modelled transitions for a value function, in addition to the real transitions. Such methods can sometimes be extended to use of non-parametric models, such as when the transitions are simply stored and 'replayed'[21]to the learning algorithm.
There are other ways to use models than to update a value function.
[22]For instance, inmodel predictive controlthe model is used to update the behavior directly.
Theory[edit]Both the asymptotic and finite-sample behaviors of most algorithms are well understood. Algorithms with provably good online performance (addressing the exploration issue) are known.
Efficient exploration of MDPs is given in Burnetas and Katehakis (1997).
[9]Finite-time performance bounds have also appeared for many algorithms, but these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations.
For incremental algorithms, asymptotic convergence issues have been settled[clarification needed]. Temporal-difference-based algorithms converge under a wider set of conditions than was previously possible (for example, when used with arbitrary, smooth function approximation).
Research[edit]Research topics includeComparison of reinforcement learning algorithms[edit]Associative reinforcement learning[edit]Associative reinforcement learning tasks combine facets of stochastic learning automata tasks and supervised learning pattern classification tasks. In associative reinforcement learning tasks, the learning system interacts in a closed loop with its environment.
[37]Deep reinforcement learning[edit]This approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space.
[38]The work on learning ATARI games by GoogleDeepMindincreased attention todeep reinforcement learningorend-to-end reinforcement learning.
[39]Adversarial deep reinforcement learning[edit]Adversarial deep reinforcement learning is an active area of research in reinforcement learning focusing on vulnerabilities of learned policies. In this research area some studies initially showed that reinforcement learning policies are susceptible to imperceptible adversarial manipulations.
[40][41][42]While some methods have been proposed to overcome these susceptibilities, in the most recent studies it has been shown that these proposed solutions are far from providing an accurate representation of current vulnerabilities of deep reinforcement learning policies.
[43]Inverse reinforcement learning[edit]In inverse reinforcement learning (IRL), no reward function is given. Instead, the reward function is inferred given an observed behavior from an expert. The idea is to mimic observed behavior, which is often optimal or close to optimal.
[44]Safe reinforcement learning[edit]Safe reinforcement learning (SRL) can be defined as the process of learning policies that maximize the expectation of the return in problems in which it is important to ensure reasonable system performance and/or respect safety constraints during the learning and/or deployment processes.
[45]Partially supervised reinforcement learning (PSRL)[edit]In PSRL algorithms the advantages of supervised and RL based approaches are synergistically combined. For example the control policy learnt by an inverse ANN based approach to control a nonlinear system can be refined using RL thereby avoiding the computational cost incurred by starting from a random policy in traditional RL. Partially supervised approaches can alleviate the need for extensive training data in supervised learning while reducing the need for costly exhaustive random exploration in pure RL.
[2]See also[edit]References[edit]Further reading[edit]External links[edit]Navigation menuSearch
